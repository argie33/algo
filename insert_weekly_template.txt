def insert_symbol_results(cur, symbol, timeframe, df):
    insert_q = """
      INSERT INTO buy_sell_weekly (
        symbol, timeframe, date,
        open, high, low, close, volume,
        signal, buylevel, stoplevel, inposition,
        -- Signal state columns
        signal_state, signal_state_changed_date, previous_signal_state, days_in_current_state,
        -- Entry quality
        extension_from_pivot_pct, entry_window, close_range_position,
        gap_from_prev_close_pct, is_gap_up, is_gap_down, days_since_pivot_break,
        -- Setup detection
        distance_to_pivot_pct, consolidation_days, atr_contraction_ratio,
        -- Follow-through
        prev_day_close, prev_day_signal_state, is_follow_through_day,
        follow_through_day_number, follow_through_gain_pct,
        consecutive_up_days, consecutive_down_days, held_above_pivot,
        -- Volume
        volume_percentile, volume_surge_on_breakout,
        -- Pullback tracking
        distance_to_21ema_pct, pullback_stage, pullback_days,
        pct_retraced_from_high, avg_daily_change_last_5days,
        -- Position management
        entry_price, entry_date, entry_quality_grade,
        days_in_position, current_pnl_pct, current_r_multiple,
        max_favorable_excursion_pct, max_adverse_excursion_pct,
        peak_price_in_trade, lowest_price_in_trade,
        initial_stop_loss, current_stop_loss, trailing_stop_type,
        -- Exit tracking
        exit_date, exit_price, exit_reason,
        trade_result_pct, trade_duration_days, was_winner,
        -- Failed breakout
        is_failed_breakout, days_above_pivot_before_failure, max_extension_before_failure_pct
      ) VALUES (
        %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,
        %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,
        %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s
      )
      ON CONFLICT (symbol, timeframe, date) DO UPDATE SET
        signal = EXCLUDED.signal,
        buylevel = EXCLUDED.buylevel,
        stoplevel = EXCLUDED.stoplevel,
        inposition = EXCLUDED.inposition,
        -- Update signal state columns
        signal_state = EXCLUDED.signal_state,
        signal_state_changed_date = EXCLUDED.signal_state_changed_date,
        previous_signal_state = EXCLUDED.previous_signal_state,
        days_in_current_state = EXCLUDED.days_in_current_state,
        extension_from_pivot_pct = EXCLUDED.extension_from_pivot_pct,
        entry_window = EXCLUDED.entry_window,
        close_range_position = EXCLUDED.close_range_position,
        gap_from_prev_close_pct = EXCLUDED.gap_from_prev_close_pct,
        is_gap_up = EXCLUDED.is_gap_up,
        is_gap_down = EXCLUDED.is_gap_down,
        days_since_pivot_break = EXCLUDED.days_since_pivot_break,
        distance_to_pivot_pct = EXCLUDED.distance_to_pivot_pct,
        consolidation_days = EXCLUDED.consolidation_days,
        atr_contraction_ratio = EXCLUDED.atr_contraction_ratio,
        prev_day_close = EXCLUDED.prev_day_close,
        prev_day_signal_state = EXCLUDED.prev_day_signal_state,
        is_follow_through_day = EXCLUDED.is_follow_through_day,
        follow_through_day_number = EXCLUDED.follow_through_day_number,
        follow_through_gain_pct = EXCLUDED.follow_through_gain_pct,
        consecutive_up_days = EXCLUDED.consecutive_up_days,
        consecutive_down_days = EXCLUDED.consecutive_down_days,
        held_above_pivot = EXCLUDED.held_above_pivot,
        volume_percentile = EXCLUDED.volume_percentile,
        volume_surge_on_breakout = EXCLUDED.volume_surge_on_breakout,
        distance_to_21ema_pct = EXCLUDED.distance_to_21ema_pct,
        pullback_stage = EXCLUDED.pullback_stage,
        pullback_days = EXCLUDED.pullback_days,
        pct_retraced_from_high = EXCLUDED.pct_retraced_from_high,
        avg_daily_change_last_5days = EXCLUDED.avg_daily_change_last_5days,
        entry_price = EXCLUDED.entry_price,
        entry_date = EXCLUDED.entry_date,
        entry_quality_grade = EXCLUDED.entry_quality_grade,
        days_in_position = EXCLUDED.days_in_position,
        current_pnl_pct = EXCLUDED.current_pnl_pct,
        current_r_multiple = EXCLUDED.current_r_multiple,
        max_favorable_excursion_pct = EXCLUDED.max_favorable_excursion_pct,
        max_adverse_excursion_pct = EXCLUDED.max_adverse_excursion_pct,
        peak_price_in_trade = EXCLUDED.peak_price_in_trade,
        lowest_price_in_trade = EXCLUDED.lowest_price_in_trade,
        initial_stop_loss = EXCLUDED.initial_stop_loss,
        current_stop_loss = EXCLUDED.current_stop_loss,
        trailing_stop_type = EXCLUDED.trailing_stop_type,
        exit_date = EXCLUDED.exit_date,
        exit_price = EXCLUDED.exit_price,
        exit_reason = EXCLUDED.exit_reason,
        trade_result_pct = EXCLUDED.trade_result_pct,
        trade_duration_days = EXCLUDED.trade_duration_days,
        was_winner = EXCLUDED.was_winner,
        is_failed_breakout = EXCLUDED.is_failed_breakout,
        days_above_pivot_before_failure = EXCLUDED.days_above_pivot_before_failure,
        max_extension_before_failure_pct = EXCLUDED.max_extension_before_failure_pct;
    """
    inserted = 0
    for idx, row in df.iterrows():
        try:
            # Check for NaNs or missing values in essential columns
            vals = [
                row.get("open"),
                row.get("high"),
                row.get("low"),
                row.get("close"),
                row.get("volume"),
                row.get("Signal"),
                row.get("buyLevel"),
                row.get("stopLevel"),
                row.get("inPosition"),
            ]
            if any(pd.isnull(v) for v in vals):
                logging.warning(
                    f"Skipping row {idx} for {symbol} {timeframe} due to NaN: {vals}"
                )
                continue

            # Helper function to safely extract values
            def safe_get(key, convert_fn=None, default=None):
                val = row.get(key)
                if pd.isna(val) or val is None:
                    return default
                if convert_fn:
                    try:
                        return convert_fn(val)
                    except:
                        return default
                return val

            # Signal state values
            signal_state = safe_get("signal_state", str, "NONE")
            signal_state_changed_date = safe_get("signal_state_changed_date")
            signal_state_changed_date = signal_state_changed_date.date() if pd.notna(signal_state_changed_date) else None
            previous_signal_state = safe_get("previous_signal_state", str)
            days_in_current_state = safe_get("days_in_current_state", int, 0)

            # Entry quality
            extension_from_pivot_pct = safe_get("extension_from_pivot_pct", float)
            entry_window = safe_get("entry_window", str)
            close_range_position = safe_get("close_range_position", float)
            gap_from_prev_close_pct = safe_get("gap_from_prev_close_pct", float)
            is_gap_up = safe_get("is_gap_up", bool, False)
            is_gap_down = safe_get("is_gap_down", bool, False)
            days_since_pivot_break = safe_get("days_since_pivot_break", int)

            # Setup detection
            distance_to_pivot_pct = safe_get("distance_to_pivot_pct", float)
            consolidation_days = safe_get("consolidation_days", int, 0)
            atr_contraction_ratio = safe_get("atr_contraction_ratio", float)

            # Follow-through
            prev_day_close = safe_get("prev_close", float)
            prev_day_signal_state = safe_get("prev_day_signal_state", str)
            is_follow_through_day = safe_get("is_follow_through_day", bool, False)
            follow_through_day_number = safe_get("follow_through_day_number", int, 0)
            follow_through_gain_pct = safe_get("follow_through_gain_pct", float, 0.0)
            consecutive_up_days = safe_get("consecutive_up_days", int, 0)
            consecutive_down_days = safe_get("consecutive_down_days", int, 0)
            held_above_pivot = safe_get("held_above_pivot", bool, False)

            # Volume
            volume_percentile = safe_get("volume_percentile", int, 50)
            volume_surge_on_breakout = safe_get("volume_surge_on_breakout", bool, False)

            # Pullback tracking
            distance_to_21ema_pct = safe_get("distance_to_21ema_pct", float)
            pullback_stage = safe_get("pullback_stage", str)
            pullback_days = safe_get("pullback_days", int, 0)
            pct_retraced_from_high = safe_get("pct_retraced_from_high", float, 0.0)
            avg_daily_change_last_5days = safe_get("avg_daily_change_last_5days", float)

            # Position management
            entry_price = safe_get("entry_price", float)
            entry_date = safe_get("entry_date")
            entry_date = entry_date.date() if pd.notna(entry_date) else None
            entry_quality_grade = safe_get("entry_quality_grade", str)
            days_in_position = safe_get("days_in_position", int, 0)
            current_pnl_pct = safe_get("current_pnl_pct", float, 0.0)
            current_r_multiple = safe_get("current_r_multiple", float, 0.0)
            max_favorable_excursion_pct = safe_get("max_favorable_excursion_pct", float, 0.0)
            max_adverse_excursion_pct = safe_get("max_adverse_excursion_pct", float, 0.0)
            peak_price_in_trade = safe_get("peak_price_in_trade", float, 0.0)
            lowest_price_in_trade = safe_get("lowest_price_in_trade", float, 0.0)
            initial_stop_loss = safe_get("initial_stop_loss", float)
            current_stop_loss = safe_get("current_stop_loss", float)
            trailing_stop_type = safe_get("trailing_stop_type", str)

            # Exit tracking
            exit_date = safe_get("exit_date")
            exit_date = exit_date.date() if pd.notna(exit_date) else None
            exit_price = safe_get("exit_price", float)
            exit_reason = safe_get("exit_reason", str)
            trade_result_pct = safe_get("trade_result_pct", float, 0.0)
            trade_duration_days = safe_get("trade_duration_days", int, 0)
            was_winner = safe_get("was_winner", bool, False)

            # Failed breakout
            is_failed_breakout = safe_get("is_failed_breakout", bool, False)
            days_above_pivot_before_failure = safe_get("days_above_pivot_before_failure", int, 0)
            max_extension_before_failure_pct = safe_get("max_extension_before_failure_pct", float, 0.0)

            # Build tuple of values (68 values total)
            values_tuple = (
                symbol,
                timeframe,
                row["date"].date(),
                float(row["open"]),
                float(row["high"]),
                float(row["low"]),
                float(row["close"]),
                int(row["volume"]),
                row["Signal"],
                float(row["buyLevel"]),
                float(row["stopLevel"]),
                bool(row["inPosition"]),
                # Signal state (4 values)
                signal_state,
                signal_state_changed_date,
                previous_signal_state,
                days_in_current_state,
                # Entry quality (7 values)
                extension_from_pivot_pct,
                entry_window,
                close_range_position,
                gap_from_prev_close_pct,
                is_gap_up,
                is_gap_down,
                days_since_pivot_break,
                # Setup detection (3 values)
                distance_to_pivot_pct,
                consolidation_days,
                atr_contraction_ratio,
                # Follow-through (8 values)
                prev_day_close,
                prev_day_signal_state,
                is_follow_through_day,
                follow_through_day_number,
                follow_through_gain_pct,
                consecutive_up_days,
                consecutive_down_days,
                held_above_pivot,
                # Volume (2 values)
                volume_percentile,
                volume_surge_on_breakout,
                # Pullback tracking (5 values)
                distance_to_21ema_pct,
                pullback_stage,
                pullback_days,
                pct_retraced_from_high,
                avg_daily_change_last_5days,
                # Position management (13 values)
                entry_price,
                entry_date,
                entry_quality_grade,
                days_in_position,
                current_pnl_pct,
                current_r_multiple,
                max_favorable_excursion_pct,
                max_adverse_excursion_pct,
                peak_price_in_trade,
                lowest_price_in_trade,
                initial_stop_loss,
                current_stop_loss,
                trailing_stop_type,
                # Exit tracking (6 values)
                exit_date,
                exit_price,
                exit_reason,
                trade_result_pct,
                trade_duration_days,
                was_winner,
                # Failed breakout (3 values)
                is_failed_breakout,
                days_above_pivot_before_failure,
                max_extension_before_failure_pct,
            )
            # Debug: print tuple size and placeholder count on first row
            if idx == 0:
                logging.info(f"Values tuple size: {len(values_tuple)}")
                placeholder_count = insert_q.count('%s')
                logging.info(f"Placeholder count in SQL: {placeholder_count}")
            cur.execute(insert_q, values_tuple)
            inserted += 1
        except Exception as e:
            logging.error(
                f"Insert failed for {symbol} {timeframe} row {idx}: {e} | row={row}"
            )
    logging.info(f"Inserted {inserted} rows for {symbol} {timeframe}")
