AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Real-time WebSocket Infrastructure for Live Market Data Streaming
  Foundation for future HFT capabilities. Cost-optimized for current needs
  with ElastiCache Redis, DynamoDB, and API Gateway WebSocket.
  Updated for stack redeploy after rollback fix. Force fresh deploy v3 - Clean slate.

Parameters:
  Environment:
    Type: String
    Default: dev
    AllowedValues: [dev, staging, prod]
    Description: Environment name

Resources:

  #############################################################################
  # LAMBDA EXECUTION ROLE
  #############################################################################
  
  WebSocketLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-websocket-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: WebSocketPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - apigateway:POST
                  - apigateway:GET
                  - apigateway:DELETE
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:*/*/*/*'
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: 
                  - !GetAtt ConnectionsTable.Arn
                  - !GetAtt SubscriptionsTable.Arn
                  - !GetAtt MarketDataTable.Arn
                  - !Sub '${ConnectionsTable.Arn}/index/*'
                  - !Sub '${SubscriptionsTable.Arn}/index/*'
              - Effect: Allow
                Action:
                  - elasticache:*
                Resource: '*'
              - Effect: Allow
                Action:
                  - execute-api:ManageConnections
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'
              - Effect: Allow
                Action:
                  - execute-api:Invoke
                Resource: 'arn:aws:execute-api:*:*:*'
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: 
                  - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:alpaca-api-credentials-*'
                  - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:polygon-api-credentials-*'
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-*'

  #############################################################################
  # ELASTICACHE REDIS - LOW LATENCY CACHING
  #############################################################################
  
  ElastiCacheSubnetGroup:
    Type: AWS::ElastiCache::SubnetGroup
    Properties:
      Description: Subnet group for ElastiCache Redis cluster
      SubnetIds:
        - !ImportValue StocksCore-PublicSubnet1Id
        - !ImportValue StocksCore-PublicSubnet2Id
  
  ElastiCacheSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for ElastiCache Redis cluster
      VpcId: !ImportValue StocksCore-VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 6379
          ToPort: 6379
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
          Description: Redis access from Lambda functions
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-elasticache-sg'

  ElastiCacheCluster:
    Type: AWS::ElastiCache::ReplicationGroup
    Properties:
      ReplicationGroupDescription: 'WebSocket Live Data Redis cluster'
      ReplicationGroupId: !Sub '${AWS::StackName}-ws-cache'
      CacheNodeType: cache.t3.micro  # Start small, can scale up
      Engine: redis
      EngineVersion: '7.0'
      NumCacheClusters: 1  # Single node for cost optimization
      AutomaticFailoverEnabled: false  # Required when NumCacheClusters < 2
      MultiAZEnabled: false  # Cannot be true with single cluster
      CacheSubnetGroupName: !Ref ElastiCacheSubnetGroup
      SecurityGroupIds:
        - !Ref ElastiCacheSecurityGroup
      AtRestEncryptionEnabled: false  # Disable for t3.micro
      TransitEncryptionEnabled: false  # Disable for t3.micro
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ws-cache'
        - Key: Purpose
          Value: WebSocket-Live-Data-Cache

  #############################################################################
  # DYNAMODB TABLES
  #############################################################################
  
  # Connection tracking table
  ConnectionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${AWS::StackName}-connections'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: connectionId
          AttributeType: S
        - AttributeName: userId
          AttributeType: S
      KeySchema:
        - AttributeName: connectionId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: UserIdIndex
          KeySchema:
            - AttributeName: userId
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-connections'

  # Subscriptions table for managing WebSocket subscriptions
  SubscriptionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${AWS::StackName}-subscriptions'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: subscriptionId
          AttributeType: S
        - AttributeName: connectionId
          AttributeType: S
      KeySchema:
        - AttributeName: subscriptionId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: ConnectionIndex
          KeySchema:
            - AttributeName: connectionId
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-subscriptions'

  # Market data table for latest quotes
  MarketDataTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${AWS::StackName}-market-data'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: symbol
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: N
      KeySchema:
        - AttributeName: symbol
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-market-data'

  #############################################################################
  # API GATEWAY WEBSOCKET API
  #############################################################################
  
  WebSocketApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub '${AWS::StackName}-websocket-api'
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: $request.body.action
      Description: Real-time WebSocket API for live market data
      Tags:
        Name: !Sub '${AWS::StackName}-websocket-api'
        Purpose: Live-Market-Data-WebSocket

  WebSocketStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref WebSocketApi
      StageName: !Ref Environment
      Description: WebSocket API stage
      DefaultRouteSettings:
        ThrottlingBurstLimit: 1000
        ThrottlingRateLimit: 500
      Tags:
        Name: !Sub '${AWS::StackName}-websocket-stage'

  #############################################################################
  # LAMBDA FUNCTIONS
  #############################################################################
  
  # Security group for Lambda functions
  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for WebSocket Lambda functions with API access
      VpcId: !ImportValue StocksCore-VpcId
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
          Description: All outbound traffic (including API Gateway access)
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: HTTPS inbound for API communication
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-lambda-sg'
        - Key: Purpose
          Value: WebSocket-API-Communication

  # WebSocket connection handler
  ConnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-websocket-connect'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt WebSocketLambdaRole.Arn
      Timeout: 30
      MemorySize: 512
      Environment:
        Variables:
          CONNECTIONS_TABLE: !Ref ConnectionsTable
          SUBSCRIPTIONS_TABLE: !Ref SubscriptionsTable
          ELASTICACHE_ENDPOINT: !GetAtt ElastiCacheCluster.PrimaryEndPoint.Address
          ELASTICACHE_PORT: !GetAtt ElastiCacheCluster.PrimaryEndPoint.Port
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds:
          - !ImportValue StocksCore-PublicSubnet1Id
          - !ImportValue StocksCore-PublicSubnet2Id
      Code:
        ZipFile: |
          import json
          import boto3
          import redis
          import logging
          import os
          from datetime import datetime, timedelta
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          dynamodb = boto3.resource('dynamodb')
          connections_table = dynamodb.Table(os.environ['CONNECTIONS_TABLE'])
          
          def lambda_handler(event, context):
              connection_id = event['requestContext']['connectionId']
              user_id = event.get('queryStringParameters', {}).get('userId', 'anonymous')
              
              try:
                  # Store connection in DynamoDB
                  ttl = int((datetime.now() + timedelta(hours=24)).timestamp())
                  connections_table.put_item(
                      Item={
                          'connectionId': connection_id,
                          'userId': user_id,
                          'connectedAt': datetime.now().isoformat(),
                          'ttl': ttl,
                          'subscriptions': []
                      }
                  )
                  
                  # Cache active connection in Redis for fast lookup
                  try:
                      redis_client = redis.Redis(
                          host=os.environ['ELASTICACHE_ENDPOINT'],
                          port=int(os.environ['ELASTICACHE_PORT']),
                          decode_responses=True,
                          socket_connect_timeout=2,
                          socket_timeout=2
                      )
                      redis_client.sadd('active_connections', connection_id)
                      redis_client.hset(f'connection:{connection_id}', 'userId', user_id)
                      redis_client.expire(f'connection:{connection_id}', 86400)  # 24 hours
                  except Exception as redis_error:
                      logger.warning(f"Redis caching failed: {redis_error}")
                  
                  logger.info(f"Connected: {connection_id} for user: {user_id}")
                  return {'statusCode': 200}
                  
              except Exception as e:
                  logger.error(f"Connection failed: {str(e)}")
                  return {'statusCode': 500, 'body': str(e)}
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-websocket-connect'

  # WebSocket disconnect handler
  DisconnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-websocket-disconnect'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt WebSocketLambdaRole.Arn
      Timeout: 30
      MemorySize: 512
      Environment:
        Variables:
          CONNECTIONS_TABLE: !Ref ConnectionsTable
          SUBSCRIPTIONS_TABLE: !Ref SubscriptionsTable
          ELASTICACHE_ENDPOINT: !GetAtt ElastiCacheCluster.PrimaryEndPoint.Address
          ELASTICACHE_PORT: !GetAtt ElastiCacheCluster.PrimaryEndPoint.Port
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds:
          - !ImportValue StocksCore-PublicSubnet1Id
          - !ImportValue StocksCore-PublicSubnet2Id
      Code:
        ZipFile: |
          import json
          import boto3
          import redis
          import logging
          import os
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          dynamodb = boto3.resource('dynamodb')
          connections_table = dynamodb.Table(os.environ['CONNECTIONS_TABLE'])
          
          def lambda_handler(event, context):
              connection_id = event['requestContext']['connectionId']
              
              try:
                  # Remove from DynamoDB
                  connections_table.delete_item(Key={'connectionId': connection_id})
                  
                  # Remove from Redis cache
                  try:
                      redis_client = redis.Redis(
                          host=os.environ['ELASTICACHE_ENDPOINT'],
                          port=int(os.environ['ELASTICACHE_PORT']),
                          decode_responses=True,
                          socket_connect_timeout=2,
                          socket_timeout=2
                      )
                      redis_client.srem('active_connections', connection_id)
                      redis_client.delete(f'connection:{connection_id}')
                  except Exception as redis_error:
                      logger.warning(f"Redis cleanup failed: {redis_error}")
                  
                  logger.info(f"Disconnected: {connection_id}")
                  return {'statusCode': 200}
                  
              except Exception as e:
                  logger.error(f"Disconnect failed: {str(e)}")
                  return {'statusCode': 500, 'body': str(e)}
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-websocket-disconnect'

  # Message handler for subscriptions
  MessageFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-websocket-message'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt WebSocketLambdaRole.Arn
      Timeout: 30
      MemorySize: 512
      Environment:
        Variables:
          CONNECTIONS_TABLE: !Ref ConnectionsTable
          SUBSCRIPTIONS_TABLE: !Ref SubscriptionsTable
          MARKET_DATA_TABLE: !Ref MarketDataTable
          ELASTICACHE_ENDPOINT: !GetAtt ElastiCacheCluster.PrimaryEndPoint.Address
          ELASTICACHE_PORT: !GetAtt ElastiCacheCluster.PrimaryEndPoint.Port
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds:
          - !ImportValue StocksCore-PublicSubnet1Id
          - !ImportValue StocksCore-PublicSubnet2Id
      Code:
        ZipFile: |
          import json
          import boto3
          import redis
          import logging
          import os
          from datetime import datetime
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          dynamodb = boto3.resource('dynamodb')
          connections_table = dynamodb.Table(os.environ['CONNECTIONS_TABLE'])
          market_data_table = dynamodb.Table(os.environ['MARKET_DATA_TABLE'])
          
          def lambda_handler(event, context):
              connection_id = event['requestContext']['connectionId']
              
              try:
                  # Parse message
                  body = json.loads(event['body'])
                  action = body.get('action')
                  
                  if action == 'subscribe':
                      return handle_subscribe(connection_id, body)
                  elif action == 'unsubscribe':
                      return handle_unsubscribe(connection_id, body)
                  elif action == 'ping':
                      return handle_ping(connection_id)
                  else:
                      return {'statusCode': 400, 'body': 'Unknown action'}
                      
              except Exception as e:
                  logger.error(f"Message handling failed: {str(e)}")
                  return {'statusCode': 500, 'body': str(e)}
          
          def handle_subscribe(connection_id, body):
              symbols = body.get('symbols', [])
              channel = body.get('channel', 'market_data')
              
              # Update connection subscriptions
              connections_table.update_item(
                  Key={'connectionId': connection_id},
                  UpdateExpression='SET subscriptions = list_append(if_not_exists(subscriptions, :empty_list), :symbols)',
                  ExpressionAttributeValues={
                      ':empty_list': [],
                      ':symbols': symbols
                  }
              )
              
              # Cache subscription in Redis
              try:
                  redis_client = redis.Redis(
                      host=os.environ['ELASTICACHE_ENDPOINT'],
                      port=int(os.environ['ELASTICACHE_PORT']),
                      decode_responses=True,
                      socket_connect_timeout=2,
                      socket_timeout=2
                  )
                  for symbol in symbols:
                      redis_client.sadd(f'subscribers:{symbol}', connection_id)
              except Exception as redis_error:
                  logger.warning(f"Redis subscription failed: {redis_error}")
              
              logger.info(f"Subscribed {connection_id} to {symbols}")
              return {'statusCode': 200}
          
          def handle_unsubscribe(connection_id, body):
              symbols = body.get('symbols', [])
              
              # Remove from Redis subscriptions
              try:
                  redis_client = redis.Redis(
                      host=os.environ['ELASTICACHE_ENDPOINT'],
                      port=int(os.environ['ELASTICACHE_PORT']),
                      decode_responses=True,
                      socket_connect_timeout=2,
                      socket_timeout=2
                  )
                  for symbol in symbols:
                      redis_client.srem(f'subscribers:{symbol}', connection_id)
              except Exception as redis_error:
                  logger.warning(f"Redis unsubscribe failed: {redis_error}")
              
              logger.info(f"Unsubscribed {connection_id} from {symbols}")
              return {'statusCode': 200}
          
          def handle_ping(connection_id):
              return {'statusCode': 200, 'body': 'pong'}
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-websocket-message'

  # Market data broadcaster (scheduled function)
  MarketDataBroadcaster:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-market-data-broadcaster'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt WebSocketLambdaRole.Arn
      Timeout: 300
      MemorySize: 1024
      Environment:
        Variables:
          CONNECTIONS_TABLE: !Ref ConnectionsTable
          SUBSCRIPTIONS_TABLE: !Ref SubscriptionsTable
          MARKET_DATA_TABLE: !Ref MarketDataTable
          ELASTICACHE_ENDPOINT: !GetAtt ElastiCacheCluster.PrimaryEndPoint.Address
          ELASTICACHE_PORT: !GetAtt ElastiCacheCluster.PrimaryEndPoint.Port
          WEBSOCKET_API_ENDPOINT: !Sub 'https://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
          API_ENDPOINT: https://2m14opj30h.execute-api.us-east-1.amazonaws.com/dev

  # Real-time WebSocket handler with Alpaca integration
  RealTimeWebSocketHandler:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-websocket-realtime-handler'
      Runtime: nodejs18.x
      Handler: realBroadcaster.handler
      Role: !GetAtt WebSocketLambdaRole.Arn
      Timeout: 300
      MemorySize: 1024
      Environment:
        Variables:
          AWS_REGION: !Ref 'AWS::Region'
          ALPACA_API_KEY: !Sub '{{resolve:secretsmanager:alpaca-api-credentials:SecretString:keyId}}'
          ALPACA_SECRET_KEY: !Sub '{{resolve:secretsmanager:alpaca-api-credentials:SecretString:secretKey}}'
      Code:
        ZipFile: |
          // Placeholder - will be replaced with actual code during deployment
          exports.handler = async (event, context) => {
            return {
              statusCode: 200,
              body: JSON.stringify({ message: 'WebSocket handler placeholder' })
            };
          };
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-websocket-realtime-handler'
        - Key: TestIntegration
          Value: 'true'
  
  # Real market data broadcaster - uses actual financial APIs
  RealMarketDataBroadcaster:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-market-data-broadcaster-real'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt WebSocketLambdaRole.Arn
      Timeout: 300
      MemorySize: 1024
      Environment:
        Variables:
          CONNECTIONS_TABLE: !Ref ConnectionsTable
          SUBSCRIPTIONS_TABLE: !Ref SubscriptionsTable
          MARKET_DATA_TABLE: !Ref MarketDataTable
          WEBSOCKET_API_ENDPOINT: !Sub 'https://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds:
          - !ImportValue StocksCore-PublicSubnet1Id
          - !ImportValue StocksCore-PublicSubnet2Id
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const https = require('https');
          
          const dynamoDB = new AWS.DynamoDB.DocumentClient();
          const secretsManager = new AWS.SecretsManager();
          const apigateway = new AWS.ApiGatewayManagementApi({
            endpoint: process.env.WEBSOCKET_API_ENDPOINT
          });
          
          let alpacaCredentials = null;
          let polygonCredentials = null;
          
          async function getCredentials() {
            if (alpacaCredentials && polygonCredentials) {
              return { alpacaCredentials, polygonCredentials };
            }
            
            try {
              const [alpacaSecret, polygonSecret] = await Promise.all([
                secretsManager.getSecretValue({ SecretId: 'alpaca-api-credentials' }).promise(),
                secretsManager.getSecretValue({ SecretId: 'polygon-api-credentials' }).promise()
              ]);
              
              alpacaCredentials = JSON.parse(alpacaSecret.SecretString);
              polygonCredentials = JSON.parse(polygonSecret.SecretString);
              
              return { alpacaCredentials, polygonCredentials };
            } catch (error) {
              console.error('Failed to get API credentials:', error);
              throw new Error('API credentials not available');
            }
          }
          
          async function fetchRealMarketData(symbols) {
            const { alpacaCredentials, polygonCredentials } = await getCredentials();
            const marketData = [];
            
            // Fetch from Alpaca
            try {
              const alpacaData = await fetchFromAlpaca(symbols, alpacaCredentials);
              marketData.push(...alpacaData);
            } catch (error) {
              console.error('Alpaca fetch failed:', error);
            }
            
            // Fetch from Polygon as backup
            if (marketData.length === 0) {
              try {
                const polygonData = await fetchFromPolygon(symbols, polygonCredentials);
                marketData.push(...polygonData);
              } catch (error) {
                console.error('Polygon fetch also failed:', error);
                throw new Error('All market data sources failed');
              }
            }
            
            return marketData;
          }
          
          function fetchFromAlpaca(symbols, credentials) {
            return new Promise((resolve, reject) => {
              const params = new URLSearchParams({
                symbols: symbols.join(','),
                feed: 'iex'
              });
              
              const options = {
                hostname: 'data.alpaca.markets',
                path: `/v2/stocks/quotes/latest?${params}`,
                method: 'GET',
                headers: {
                  'APCA-API-KEY-ID': credentials.keyId,
                  'APCA-API-SECRET-KEY': credentials.secretKey
                }
              };
              
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  try {
                    const result = JSON.parse(data);
                    const marketData = [];
                    
                    if (result.quotes) {
                      for (const [symbol, quote] of Object.entries(result.quotes)) {
                        if (quote.bp && quote.ap) {
                          marketData.push({
                            symbol,
                            price: (quote.bp + quote.ap) / 2,
                            bid: quote.bp,
                            ask: quote.ap,
                            timestamp: new Date(quote.t).getTime(),
                            source: 'alpaca'
                          });
                        }
                      }
                    }
                    resolve(marketData);
                  } catch (error) {
                    reject(error);
                  }
                });
              });
              
              req.on('error', reject);
              req.setTimeout(10000, () => reject(new Error('Alpaca timeout')));
              req.end();
            });
          }
          
          function fetchFromPolygon(symbols, credentials) {
            return new Promise((resolve, reject) => {
              const params = new URLSearchParams({
                tickers: symbols.join(','),
                apikey: credentials.apiKey
              });
              
              const options = {
                hostname: 'api.polygon.io',
                path: `/v2/snapshot/locale/us/markets/stocks/tickers?${params}`,
                method: 'GET'
              };
              
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  try {
                    const result = JSON.parse(data);
                    const marketData = [];
                    
                    if (result.results) {
                      for (const item of result.results) {
                        if (item.value && item.lastQuote) {
                          marketData.push({
                            symbol: item.ticker,
                            price: item.value,
                            bid: item.lastQuote.bid,
                            ask: item.lastQuote.ask,
                            volume: item.day?.v || 0,
                            timestamp: item.updated || Date.now(),
                            source: 'polygon'
                          });
                        }
                      }
                    }
                    resolve(marketData);
                  } catch (error) {
                    reject(error);
                  }
                });
              });
              
              req.on('error', reject);
              req.setTimeout(10000, () => reject(new Error('Polygon timeout')));
              req.end();
            });
          }
          
          exports.handler = async (event) => {
            console.log('Real market data broadcaster invoked');
            
            try {
              const { symbols } = event;
              
              if (!symbols || !Array.isArray(symbols) || symbols.length === 0) {
                return {
                  statusCode: 400,
                  body: JSON.stringify({ error: 'No symbols provided' })
                };
              }
              
              console.log(`Fetching real data for symbols: ${symbols.join(', ')}`);
              const marketData = await fetchRealMarketData(symbols);
              
              console.log(`Retrieved ${marketData.length} real market data points`);
              
              return {
                statusCode: 200,
                body: JSON.stringify({
                  message: 'Real market data fetched successfully',
                  marketData,
                  symbolsRequested: symbols.length,
                  dataRetrieved: marketData.length
                })
              };
              
            } catch (error) {
              console.error('Real market data fetch failed:', error);
              return {
                statusCode: 500,
                body: JSON.stringify({
                  error: 'Real market data fetch failed',
                  message: error.message
                })
              };
            }
          };
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-real-market-data-broadcaster'
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds:
          - !ImportValue StocksCore-PublicSubnet1Id
          - !ImportValue StocksCore-PublicSubnet2Id
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          import requests
          from datetime import datetime
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          # AWS clients
          dynamodb = boto3.resource('dynamodb')
          dynamodb_client = boto3.client('dynamodb')
          apigateway = boto3.client('apigatewaymanagementapi', 
                                  endpoint_url=os.environ['WEBSOCKET_API_ENDPOINT'])
          
          def lambda_handler(event, context):
              logger.info("REAL market data broadcast starting...")
              
              try:
                  # Get active subscriptions from DynamoDB
                  subscriptions_table = dynamodb.Table(os.environ['SUBSCRIPTIONS_TABLE'])
                  response = subscriptions_table.scan(
                      FilterExpression='#status = :status',
                      ExpressionAttributeNames={'#status': 'status'},
                      ExpressionAttributeValues={':status': 'active'}
                  )
                  
                  subscriptions = response.get('Items', [])
                  logger.info(f"Found {len(subscriptions)} active subscriptions")
                  
                  if not subscriptions:
                      return {'statusCode': 200, 'body': 'No active subscriptions'}
                  
                  # Get unique symbols from subscriptions
                  symbols = set()
                  for sub in subscriptions:
                      if 'symbols' in sub and isinstance(sub['symbols'], list):
                          for symbol in sub['symbols']:
                              # Only include real stock symbols, not portfolio pseudo-symbols
                              if not symbol.startswith('PORTFOLIO_') and len(symbol) <= 5 and symbol.isalpha():
                                  symbols.add(symbol.upper())
                  
                  symbols_list = list(symbols)
                  logger.info(f"Fetching REAL data for {len(symbols_list)} symbols: {symbols_list}")
                  
                  if not symbols_list:
                      return {'statusCode': 200, 'body': 'No valid symbols to fetch'}
                  
                  # Use external real market data broadcaster
                  # Call the dedicated real broadcaster that fetches from Alpaca/Polygon APIs
                  import boto3
                  
                  lambda_client = boto3.client('lambda')
                  
                  try:
                      # Invoke the real market data broadcaster
                      response = lambda_client.invoke(
                          FunctionName=f"{os.environ.get('AWS_LAMBDA_FUNCTION_NAME', '').split('-')[0]}-market-data-broadcaster-real",
                          InvocationType='RequestResponse',
                          Payload=json.dumps({
                              'symbols': symbols_list,
                              'requestId': context.aws_request_id if context else 'manual'
                          })
                      )
                      
                      result = json.loads(response['Payload'].read())
                      
                      if response['StatusCode'] == 200 and 'body' in result:
                          broadcaster_result = json.loads(result['body'])
                          market_data = broadcaster_result.get('marketData', [])
                          
                          if not market_data:
                              logger.error("Real broadcaster returned no market data")
                              return {'statusCode': 200, 'body': 'No market data from real broadcaster'}
                      else:
                          logger.error(f"Real broadcaster failed: {result}")
                          return {'statusCode': 500, 'body': 'Real broadcaster failed'}
                          
                  except Exception as broadcaster_error:
                      logger.error(f"Failed to call real broadcaster: {broadcaster_error}")
                      return {'statusCode': 500, 'body': 'Real broadcaster invocation failed'}
                  
                  logger.info(f"Retrieved {len(market_data)} market data points")
                  
                  if not market_data:
                      return {'statusCode': 200, 'body': 'No market data retrieved'}
                  
                  # Store market data in DynamoDB
                  market_data_table = dynamodb.Table(os.environ['MARKET_DATA_TABLE'])
                  timestamp = int(datetime.now().timestamp())
                  
                  for data in market_data:
                      try:
                          market_data_table.put_item(Item={
                              'symbol': data['symbol'],
                              'timestamp': timestamp,
                              'sortKey': f"{timestamp}-{data['source']}",
                              'price': data['price'],
                              'volume': data['volume'],
                              'change': data['change'],
                              'changePercent': data['changePercent'],
                              'source': data['source'],
                              'rawData': data,
                              'ttl': timestamp + 86400  # 24 hours TTL
                          })
                      except Exception as store_error:
                          logger.warning(f"Failed to store data for {data['symbol']}: {store_error}")
                  
                  # Broadcast to WebSocket connections
                  broadcast_count = 0
                  
                  for data in market_data:
                      symbol = data['symbol']
                      
                      # Find connections subscribed to this symbol
                      subscribed_connections = [
                          sub for sub in subscriptions 
                          if 'symbols' in sub and symbol in sub['symbols']
                      ]
                      
                      if not subscribed_connections:
                          continue
                      
                      message = json.dumps({
                          'type': 'market_data_update',
                          'symbol': symbol,
                          'data': {
                              'price': data['price'],
                              'change': data['change'],
                              'changePercent': data['changePercent'],
                              'volume': data['volume'],
                              'timestamp': data['timestamp'],
                              'source': data['source']
                          },
                          'timestamp': datetime.now().isoformat()
                      })
                      
                      for subscription in subscribed_connections:
                          try:
                              apigateway.post_to_connection(
                                  ConnectionId=subscription['connectionId'],
                                  Data=message
                              )
                              broadcast_count += 1
                          except Exception as broadcast_error:
                              if hasattr(broadcast_error, 'response') and broadcast_error.response.get('Error', {}).get('Code') == 'GoneException':
                                  # Remove stale connection
                                  logger.info(f"Removing stale connection: {subscription['connectionId']}")
                                  try:
                                      subscriptions_table.delete_item(
                                          Key={'subscriptionId': subscription['subscriptionId']}
                                      )
                                  except Exception:
                                      pass
                              else:
                                  logger.warning(f"Broadcast error for {subscription['connectionId']}: {broadcast_error}")
                  
                  logger.info(f"REAL market data broadcast completed: {broadcast_count} messages sent")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'REAL market data broadcast completed',
                          'symbolsProcessed': len(symbols_list),
                          'dataPointsRetrieved': len(market_data),
                          'messagesSent': broadcast_count,
                          'subscriptions': len(subscriptions)
                      })
                  }
                  
              except Exception as e:
                  logger.error(f"REAL broadcast failed: {str(e)}")
                  return {'statusCode': 500, 'body': json.dumps({'error': str(e)})}
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-market-data-broadcaster'

  #############################################################################
  # WEBSOCKET ROUTES - Updated for Real-time Handler
  #############################################################################
  
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $connect
      AuthorizationType: NONE
      Target: !Sub 'integrations/${RealTimeConnectIntegration}'

  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $disconnect
      AuthorizationType: NONE
      Target: !Sub 'integrations/${RealTimeDisconnectIntegration}'

  SubscribeRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: subscribe
      AuthorizationType: NONE
      Target: !Sub 'integrations/${RealTimeSubscribeIntegration}'

  UnsubscribeRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: unsubscribe
      AuthorizationType: NONE
      Target: !Sub 'integrations/${RealTimeUnsubscribeIntegration}'

  PingRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: ping
      AuthorizationType: NONE
      Target: !Sub 'integrations/${RealTimePingIntegration}'

  MessageRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $default
      AuthorizationType: NONE
      Target: !Sub 'integrations/${MessageIntegration}'

  # Real-time WebSocket integrations
  RealTimeConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RealTimeWebSocketHandler.Arn}/invocations'

  RealTimeDisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RealTimeWebSocketHandler.Arn}/invocations'

  RealTimeSubscribeIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RealTimeWebSocketHandler.Arn}/invocations'

  RealTimeUnsubscribeIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RealTimeWebSocketHandler.Arn}/invocations'

  RealTimePingIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RealTimeWebSocketHandler.Arn}/invocations'

  # Legacy integrations for compatibility
  ConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ConnectFunction.Arn}/invocations'

  DisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DisconnectFunction.Arn}/invocations'

  MessageIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${MessageFunction.Arn}/invocations'

  #############################################################################
  # LAMBDA PERMISSIONS - Updated for Real-time Handler
  #############################################################################
  
  # Real-time WebSocket handler permissions
  RealTimeWebSocketPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref RealTimeWebSocketHandler
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'
  
  # Legacy permissions for compatibility
  ConnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ConnectFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'

  DisconnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref DisconnectFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'

  MessagePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref MessageFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*'

  #############################################################################
  # EVENTBRIDGE RULE FOR PERIODIC BROADCASTS
  #############################################################################
  
  BroadcastScheduleRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${AWS::StackName}-broadcast-schedule'
      Description: Trigger market data broadcast every minute
      ScheduleExpression: 'rate(1 minute)'
      State: ENABLED
      Targets:
        - Arn: !GetAtt MarketDataBroadcaster.Arn
          Id: MarketDataBroadcasterTarget

  BroadcastSchedulePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref MarketDataBroadcaster
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt BroadcastScheduleRule.Arn

  RealBroadcasterInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref RealMarketDataBroadcaster
      Action: lambda:InvokeFunction
      Principal: lambda.amazonaws.com
      SourceArn: !GetAtt MarketDataBroadcaster.Arn

#############################################################################
# OUTPUTS
#############################################################################

Outputs:
  WebSocketApiId:
    Description: WebSocket API ID
    Value: !Ref WebSocketApi
    Export:
      Name: !Sub '${AWS::StackName}-WebSocketApiId'

  WebSocketApiEndpoint:
    Description: WebSocket API endpoint
    Value: !Sub 'wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-WebSocketApiEndpoint'

  ElastiCacheEndpoint:
    Description: ElastiCache Redis endpoint
    Value: !GetAtt ElastiCacheCluster.PrimaryEndPoint.Address
    Export:
      Name: !Sub '${AWS::StackName}-ElastiCacheEndpoint'

  ConnectionsTableName:
    Description: Connections DynamoDB table name
    Value: !Ref ConnectionsTable
    Export:
      Name: !Sub '${AWS::StackName}-ConnectionsTableName'

  MarketDataTableName:
    Description: Market data DynamoDB table name
    Value: !Ref MarketDataTable
    Export:
      Name: !Sub '${AWS::StackName}-MarketDataTableName'