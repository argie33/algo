name: deploy-app-stocks

on:
  workflow_dispatch:
    inputs:
      loaders:
        description: 'Comma-separated list of loaders to run (leave empty for auto-detection)'
        required: false
        default: ''
      environment:
        description: 'Deployment environment'
        required: false
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      force_all:
        description: 'Force run all loaders regardless of changes'
        required: false
        default: false
        type: boolean
  push:
    branches:
      - initialbuild
      - main
      - develop
    paths-ignore:
      - 'webapp/**'
      - 'template-webapp-lambda.yml'
      - '.github/workflows/deploy-webapp.yml'
  pull_request:
    branches:
      - initialbuild
      - main
      - develop
    paths-ignore:
      - 'webapp/**'
      - 'template-webapp-lambda.yml'
      - '.github/workflows/deploy-webapp.yml'

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  AWS_ROLE_ARN: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsDeployRole
  AWS_ROLE_SESSION: github-deploy
  FRED_API_KEY: ${{ secrets.FRED_API_KEY }}
  ECR_REPOSITORY: financial-data-loaders
  ECS_CLUSTER: stocks-cluster

jobs:
  # 1. Detect changes and prepare loader matrix
  detect-changes:
    name: Detect Changed Loaders
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
      has-changes: ${{ steps.matrix.outputs.has-changes }}
      infrastructure-changed: ${{ steps.infra.outputs.changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check infrastructure changes
        id: infra
        run: |
          if [[ "${{ github.event.inputs.force_all }}" == "true" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Infrastructure: Force rebuild requested"
            exit 0
          fi
          
          # Check if infrastructure files changed
          INFRA_FILES=$(git diff --name-only HEAD~1 HEAD | grep -E "(template-.*\.yml|requirements.txt|Dockerfile|\.github/workflows/)" || true)
          if [[ -n "$INFRA_FILES" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Infrastructure changes detected: $INFRA_FILES"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No infrastructure changes detected"
          fi

      - name: Generate loader matrix
        id: matrix
        run: |
          # Get all available loaders
          ALL_LOADERS=$(ls load*.py 2>/dev/null | sed 's/load//' | sed 's/\.py$//' | sort)
          
          # Determine which loaders to run
          if [[ "${{ github.event.inputs.loaders }}" != "" ]]; then
            # Manual input
            LOADERS_TO_RUN=$(echo "${{ github.event.inputs.loaders }}" | tr ',' '\n' | sort)
            echo "Manual loader selection: $LOADERS_TO_RUN"
          elif [[ "${{ github.event.inputs.force_all }}" == "true" ]] || [[ "${{ steps.infra.outputs.changed }}" == "true" ]]; then
            # Force all or infrastructure changed - SYMBOLS + FUNDAMENTALS + ANALYTICS (NO PRICE LOADERS)
            LOADERS_TO_RUN="stocksymbols aaiidata annualbalancesheet analystupgradedowngrade annualcashflow annualincomestatement earningshistory earningsestimate quarterlyincomestatement ttmincomestatement quarterlycashflow ttmcashflow quarterlybalancesheet revenueestimate earningsmetrics feargreed technicalsdaily calendar"
            echo "Running symbols + fundamentals + analytics loaders (NO price loaders)"
          else
            # Auto-detect based on file changes - ONLY GROUP 1 WORKING LOADERS
            CHANGED_LOADERS=$(git diff --name-only HEAD~1 HEAD | grep '^load.*\.py$' | sed 's/load//' | sed 's/\.py$//' | sort || true)
            if [[ -n "$CHANGED_LOADERS" ]]; then
              # Filter to Groups 1 & 2 fundamentals loaders (NO price loaders)
              LOADERS_TO_RUN=""
              for loader in $CHANGED_LOADERS; do
                case $loader in
                  stocksymbols|aaiidata|annualbalancesheet|analystupgradedowngrade|annualcashflow|annualincomestatement|earningshistory|earningsestimate|quarterlyincomestatement|ttmincomestatement|quarterlycashflow|ttmcashflow|quarterlybalancesheet|revenueestimate|earningsmetrics|feargreed|technicalsdaily|calendar)
                    LOADERS_TO_RUN="$LOADERS_TO_RUN $loader"
                    ;;
                esac
              done
              echo "Auto-detected symbols + fundamentals + analytics loaders: $LOADERS_TO_RUN"
            else
              LOADERS_TO_RUN=""
              echo "No loader changes detected"
            fi
          fi
          
          # Generate matrix JSON
          if [[ -n "$LOADERS_TO_RUN" ]]; then
            # Create matrix with priority classification
            MATRIX_JSON='{"include":['
            FIRST=true
            for loader in $LOADERS_TO_RUN; do
              if [[ "$FIRST" == "false" ]]; then
                MATRIX_JSON+=','
              fi
              FIRST=false
              
              # All test loaders get normal priority
              PRIORITY="normal"
              TIMEOUT=120
              
              MATRIX_JSON+="{\"loader\":\"$loader\",\"priority\":\"$PRIORITY\",\"timeout\":$TIMEOUT}"
            done
            MATRIX_JSON+=']}'
            
            echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "Generated matrix: $MATRIX_JSON"
          else
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "No loaders to run"
          fi

  # 2. Build Docker images when loaders need to run
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}

      - name: Get ECR repository URI
        id: ecr
        run: |
          # Get the ECR repository URI from CloudFormation exports
          ECR_URI=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksCore-ContainerRepositoryUri'].Value" \
            --output text)
          echo "ECR Repository URI: $ECR_URI"
          echo "repository-uri=$ECR_URI" >> $GITHUB_OUTPUT
          
          # Extract repository name from URI
          REPO_NAME=$(echo $ECR_URI | cut -d'/' -f2)
          echo "Repository name: $REPO_NAME"
          echo "repository-name=$REPO_NAME" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx for multi-platform builds
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image for ARM64
        run: |
          echo "Building and pushing ARM64 loader container to ${{ steps.ecr.outputs.repository-uri }}..."
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.ecr.outputs.repository-uri }}
          
          # Build and push ARM64 image
          docker buildx build \
            --platform linux/arm64 \
            --tag ${{ steps.ecr.outputs.repository-uri }}:latest \
            --file Dockerfile.dataloader \
            --push \
            .
          
          echo "‚úÖ ARM64 Docker image built and pushed successfully to ${{ steps.ecr.outputs.repository-uri }}:latest"

  # 3. Deploy infrastructure if needed
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.infrastructure-changed == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}

      - name: Get CloudFormation S3 bucket
        id: bucket
        run: |
          BUCKET=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksCore-CfTemplatesBucketName'].Value" \
            --output text)
          echo "CF_BUCKET=$BUCKET" >> $GITHUB_OUTPUT
          echo "Using S3 bucket: $BUCKET"

      - name: Deploy ECS tasks stack
        run: |
          echo "Deploying ECS tasks infrastructure..."
          aws cloudformation deploy \
            --template-file template-app-ecs-tasks.yml \
            --stack-name stocks-ecs-tasks-stack \
            --parameter-overrides \
              RDSUsername=${{ secrets.RDS_USERNAME }} \
              RDSPassword=${{ secrets.RDS_PASSWORD }} \
              FREDApiKey=${{ secrets.FRED_API_KEY }} \
              IBKRUsername=${{ secrets.IBKR_USERNAME }} \
              IBKRPassword=${{ secrets.IBKR_PASSWORD }} \
              StockSymbolsImageTag=latest \
              EconDataImageTag=latest \
              FindataImageTag=latest \
              PriceImageTag=latest \
              PriceWeeklyImageTag=latest \
              PriceMonthlyImageTag=latest \
              TechnicalsDailyImageTag=latest \
              LoadInfoImageTag=latest \
              LoadNewsImageTag=latest \
              EarningsEstimateImageTag=latest \
              TechnicalsWeeklyImageTag=latest \
              TechnicalsMonthlyImageTag=latest \
              BuySellImageTag=latest \
              BuySellDailyImageTag=latest \
              BuySellWeeklyImageTag=latest \
              BuySellMonthlyImageTag=latest \
              SwingTraderImageTag=latest \
              CalendarImageTag=latest \
              AnalystUpgradeDowngradeImageTag=latest \
              LatestPriceDailyImageTag=latest \
              LatestPriceWeeklyImageTag=latest \
              LatestPriceMonthlyImageTag=latest \
              LatestTechnicalsDailyImageTag=latest \
              LatestTechnicalsWeeklyImageTag=latest \
              LatestTechnicalsMonthlyImageTag=latest \
              RevenueEstimateImageTag=latest \
              EarningsHistoryImageTag=latest \
              AaiiImageTag=latest \
              FearGreedImageTag=latest \
              NaaimImageTag=latest \
              EarningsMetricsImageTag=latest \
              ScoresImageTag=latest \
              PatternRecognitionImageTag=latest \
              LoadCryptoImageTag=latest \
              QuarterlyBalanceSheetImageTag=latest \
              AnnualBalanceSheetImageTag=latest \
              QuarterlyIncomeStatementImageTag=latest \
              AnnualIncomeStatementImageTag=latest \
              QuarterlyCashFlowImageTag=latest \
              AnnualCashFlowImageTag=latest \
              TTMIncomeStatementImageTag=latest \
              TTMCashFlowImageTag=latest \
              GrowthMetricsImageTag=latest \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --s3-bucket ${{ steps.bucket.outputs.CF_BUCKET }}


  # 4. Execute loaders using matrix strategy
  execute-loaders:
    name: Execute Loaders
    runs-on: ubuntu-latest
    needs: [detect-changes, build-images, deploy-infrastructure]
    if: |
      always() && 
      needs.detect-changes.outputs.has-changes == 'true' &&
      needs.build-images.result == 'success' &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
      fail-fast: false
    
    timeout-minutes: ${{ matrix.timeout }}
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}

      - name: Get infrastructure info
        id: infra
        run: |
          # Get cluster ARN
          CLUSTER_ARN=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksApp-ClusterArn'].Value" \
            --output text)
          
          # Debug: List all available task definition outputs
          echo "Available task definition outputs:"
          aws cloudformation describe-stacks \
            --stack-name stocks-ecs-tasks-stack \
            --query "Stacks[0].Outputs[].OutputKey" \
            --output table || echo "Could not list outputs"
          
          # Use correct task definition name mapping
          case "${{ matrix.loader }}" in
            aaiidata)
              TASK_DEF_NAME="aaiidata-loader"
              ;;
            calendar)
              TASK_DEF_NAME="calendar-loader"
              ;;
            earningsestimate)
              TASK_DEF_NAME="earningsestimate-loader"
              ;;
            analystupgradedowngrade)
              TASK_DEF_NAME="analyst-upgradedowngrade-loader"
              ;;
            annualbalancesheet)
              TASK_DEF_NAME="annualbalancesheet-loader"
              ;;
            annualcashflow)
              TASK_DEF_NAME="annualcashflow-loader"
              ;;
            *)
              TASK_DEF_NAME="${{ matrix.loader }}-loader"
              ;;
          esac
          echo "Looking for task definition: $TASK_DEF_NAME"
          
          # Try to get the task definition ARN from ECS directly
          TASK_DEF_ARN=$(aws ecs describe-task-definition \
            --task-definition "$TASK_DEF_NAME" \
            --query "taskDefinition.taskDefinitionArn" \
            --output text 2>/dev/null || echo "NOTFOUND")
          
          if [ "$TASK_DEF_ARN" = "NOTFOUND" ]; then
            echo "ERROR: Task definition $TASK_DEF_NAME not found in ECS"
            echo "Available task definitions:"
            aws ecs list-task-definitions --family-prefix "load" --query "taskDefinitionArns" --output table || echo "Could not list task definitions"
            exit 1
          fi
          
          # Get networking info
          SUBNET1=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksCore-PublicSubnet1Id'].Value" \
            --output text)
          SUBNET2=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksCore-PublicSubnet2Id'].Value" \
            --output text)
          SECURITY_GROUP=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksApp-EcsTasksSecurityGroupId'].Value" \
            --output text)
          
          echo "cluster=$CLUSTER_ARN" >> $GITHUB_OUTPUT
          echo "task-def=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "container-name=$TASK_DEF_NAME" >> $GITHUB_OUTPUT
          echo "subnet1=$SUBNET1" >> $GITHUB_OUTPUT
          echo "subnet2=$SUBNET2" >> $GITHUB_OUTPUT
          echo "security-group=$SECURITY_GROUP" >> $GITHUB_OUTPUT

      - name: Stop existing loader tasks
        run: |
          echo "üõë Checking for existing ${{ matrix.loader }} loader tasks to stop..."
          
          # List any running or pending tasks for this loader's task definition
          # Extract family name from task definition ARN or use the container name
          TASK_FAMILY="${{ steps.infra.outputs.container-name }}"
          
          RUNNING_TASKS=$(aws ecs list-tasks \
            --cluster "${{ steps.infra.outputs.cluster }}" \
            --family "$TASK_FAMILY" \
            --desired-status RUNNING \
            --query 'taskArns[]' \
            --output text)
          
          PENDING_TASKS=$(aws ecs list-tasks \
            --cluster "${{ steps.infra.outputs.cluster }}" \
            --family "$TASK_FAMILY" \
            --desired-status PENDING \
            --query 'taskArns[]' \
            --output text)
          
          ALL_TASKS="$RUNNING_TASKS $PENDING_TASKS"
          
          if [[ -n "$ALL_TASKS" && "$ALL_TASKS" != " " ]]; then
            echo "Found existing tasks for ${{ matrix.loader }}-loader, stopping them..."
            for task in $ALL_TASKS; do
              if [[ -n "$task" ]]; then
                echo "Stopping task: $task"
                aws ecs stop-task \
                  --cluster "${{ steps.infra.outputs.cluster }}" \
                  --task "$task" \
                  --reason "Stopped by new deployment"
              fi
            done
            echo "‚úÖ Stopped existing tasks, waiting 10 seconds for cleanup..."
            sleep 10
          else
            echo "‚úÖ No existing tasks found for ${{ matrix.loader }}-loader"
          fi

      - name: Execute loader task
        id: task
        run: |
          echo "üöÄ Starting ${{ matrix.loader }} loader (priority: ${{ matrix.priority }})"
          
          # Run ECS task
          TASK_ARN=$(aws ecs run-task \
            --cluster "${{ steps.infra.outputs.cluster }}" \
            --task-definition "${{ steps.infra.outputs.task-def }}" \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ steps.infra.outputs.subnet1 }},${{ steps.infra.outputs.subnet2 }}],securityGroups=[${{ steps.infra.outputs.security-group }}],assignPublicIp=ENABLED}" \
            --overrides "{\"containerOverrides\":[{\"name\":\"${{ steps.infra.outputs.container-name }}\",\"command\":[\"python3\",\"load${{ matrix.loader }}.py\"]}]}" \
            --query "tasks[0].taskArn" \
            --output text)
          
          echo "task-arn=$TASK_ARN" >> $GITHUB_OUTPUT
          echo "Started task: $TASK_ARN"

      - name: Wait for task completion
        timeout-minutes: 120
        run: |
          echo "‚è≥ Waiting for ${{ matrix.loader }} task to complete (max 120 minutes)..."
          
          # Wait for task to stop with timeout protection
          aws ecs wait tasks-stopped \
            --cluster "${{ steps.infra.outputs.cluster }}" \
            --tasks "${{ steps.task.outputs.task-arn }}"

      - name: Check task result
        continue-on-error: true
        id: task-result
        run: |
          # Get task details
          TASK_DETAILS=$(aws ecs describe-tasks \
            --cluster "${{ steps.infra.outputs.cluster }}" \
            --tasks "${{ steps.task.outputs.task-arn }}")
          
          # Extract exit code and details
          EXIT_CODE=$(echo "$TASK_DETAILS" | jq -r '.tasks[0].containers[0].exitCode // 1')
          STOP_REASON=$(echo "$TASK_DETAILS" | jq -r '.tasks[0].stoppedReason // "Unknown"')
          TASK_STATUS=$(echo "$TASK_DETAILS" | jq -r '.tasks[0].lastStatus // "Unknown"')
          
          echo "Task Status: $TASK_STATUS"
          echo "Exit Code: $EXIT_CODE"
          echo "Stop Reason: $STOP_REASON"
          
          # Set outputs for summary
          echo "exit-code=$EXIT_CODE" >> $GITHUB_OUTPUT
          echo "stop-reason=$STOP_REASON" >> $GITHUB_OUTPUT
          echo "task-status=$TASK_STATUS" >> $GITHUB_OUTPUT
          
          if [[ "$EXIT_CODE" != "0" ]]; then
            echo "‚ùå ${{ matrix.loader }} loader failed with exit code $EXIT_CODE"
            echo "Stop reason: $STOP_REASON"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "‚úÖ ${{ matrix.loader }} loader completed successfully"
            echo "success=true" >> $GITHUB_OUTPUT
          fi

  # 5. Summary and notifications
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, build-images, deploy-infrastructure, execute-loaders]
    if: always()
    
    steps:
      - name: Generate summary
        run: |
          echo "## üìä Deployment Summary"
          echo "- **Infrastructure**: ${{ needs.deploy-infrastructure.result || 'skipped' }}"
          echo "- **Loaders executed**: ${{ needs.execute-loaders.result || 'skipped' }}"
          echo "- **Changes detected**: ${{ needs.detect-changes.outputs.has-changes }}"
          
          if [[ "${{ needs.execute-loaders.result }}" == "success" ]]; then
            echo "‚úÖ All loaders completed successfully"
          elif [[ "${{ needs.execute-loaders.result }}" == "failure" ]]; then
            echo "‚ùå Some loaders failed - check individual job logs"
          else
            echo "‚ÑπÔ∏è No loaders were executed"
          fi
          
          echo ""
          echo "**Matrix used:**"
          echo '${{ needs.detect-changes.outputs.matrix }}' | jq -r '.include[] | "- \(.loader) (\(.priority) priority, \(.timeout)m timeout)"' || echo "No matrix generated"

      - name: Report status
        run: |
          if [[ "${{ needs.execute-loaders.result }}" == "failure" ]]; then
            echo "‚ùå Deployment had failures"
            exit 1
          else
            echo "‚úÖ Deployment completed successfully"
          fi