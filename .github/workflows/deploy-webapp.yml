name: deploy-webapp

on:  
  push:
    branches:
      - '*'
    paths:
      - 'webapp/**'
      - 'template-webapp-lambda.yml'
      - '.github/workflows/deploy-webapp.yml'
      - 'webapp-db-init.js'
      - 'Dockerfile.webapp-db-init'
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  AWS_ROLE_ARN: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsDeployRole
  AWS_ROLE_SESSION: github-deploy
  NODE_VERSION: '18.x'

jobs:
################################################################################
# 1) Determine environment based on branch                                     #
################################################################################
  setup:
    name: Setup environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      stack_name: ${{ steps.env.outputs.stack_name }}
    steps:
      - name: Determine environment
        id: env
        run: |
          # Force everything to dev environment for now
          echo "environment=dev" >> $GITHUB_OUTPUT
          echo "stack_name=stocks-webapp-dev" >> $GITHUB_OUTPUT
          echo "Deploying to environment: dev"
################################################################################
# 2) Detect changed components                                                 #
################################################################################
  filter:
    name: Detect changed components
    needs: setup
    runs-on: ubuntu-latest
    outputs:
      webapp:     ${{ steps.paths.outputs.webapp }}
      lambda:     ${{ steps.paths.outputs.lambda }}
      frontend:   ${{ steps.paths.outputs.frontend }}
      template:   ${{ steps.paths.outputs.template }}
      any:        ${{ steps.any.outputs.any }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - id: paths
        name: Which files changed?
        uses: dorny/paths-filter@v2
        with:
          base: ${{ github.event.before != '0000000000000000000000000000000000000000' && github.event.before || 'HEAD~1' }}
          filters: |
            webapp:
              - 'webapp/**'
            lambda:
              - 'webapp/lambda/**'
              - 'webapp/backend/**'
            frontend:
              - 'webapp/frontend/**'
            template:
              - 'template-webapp-lambda.yml'
              - '.github/workflows/deploy-webapp.yml'
      - id: any
        name: Any relevant changes?
        run: |
          if [[ "${{ steps.paths.outputs.webapp }}" == "true" || "${{ steps.paths.outputs.lambda }}" == "true" || "${{ steps.paths.outputs.frontend }}" == "true" || "${{ steps.paths.outputs.template }}" == "true" ]]; then
            echo "any=true" >> $GITHUB_OUTPUT
          else
            echo "any=false" >> $GITHUB_OUTPUT
          fi
################################################################################
# 3) Deploy webapp infrastructure                                              #
################################################################################
  deploy_infrastructure:
    name: Deploy webapp infrastructure
    needs: [setup, filter]
    if: ${{ needs.filter.outputs.template == 'true' || needs.filter.outputs.any == 'true' }}
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT_NAME: ${{ needs.setup.outputs.environment }}
      STACK_NAME: ${{ needs.setup.outputs.stack_name }}
    outputs:
      bucket_prefix: ${{ steps.stack_outputs.outputs.bucket_prefix }}
      cloudfront_id: ${{ steps.stack_outputs.outputs.cloudfront_id }}
      api_url: ${{ steps.stack_outputs.outputs.api_url }}
      website_url: ${{ steps.stack_outputs.outputs.website_url }}
      environment: ${{ needs.setup.outputs.environment }}
      stack_name: ${{ needs.setup.outputs.stack_name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region:        ${{ env.AWS_REGION }}
          role-to-assume:    ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}

      - name: Get database connection info from stacks
        id: db_info
        run: |
          DB_SECRET_ARN=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksApp-SecretArn'].Value" \
            --output text)
          DB_ENDPOINT=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksApp-DBEndpoint'].Value" \
            --output text)
          
          # Validate that we got the values
          if [[ -z "$DB_SECRET_ARN" || "$DB_SECRET_ARN" == "None" ]]; then
            echo "‚ùå Failed to get database secret ARN from app stack exports"
            exit 1
          fi
          
          if [[ -z "$DB_ENDPOINT" || "$DB_ENDPOINT" == "None" ]]; then
            echo "‚ùå Failed to get database endpoint from app stack exports"
            exit 1
          fi
          
          echo "DB_SECRET_ARN=$DB_SECRET_ARN" >> $GITHUB_OUTPUT
          echo "DB_ENDPOINT=$DB_ENDPOINT" >> $GITHUB_OUTPUT
          echo "Using database secret: $DB_SECRET_ARN"
          echo "Using database endpoint: $DB_ENDPOINT"
      
      - name: Get CloudFormation templates bucket from core stack
        id: bucket
        run: |
          BUCKET=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksCore-CfTemplatesBucketName'].Value" \
            --output text)
          
          # Validate bucket name
          if [[ -z "$BUCKET" || "$BUCKET" == "None" ]]; then
            echo "‚ùå Failed to get CloudFormation templates bucket from core stack exports"
            exit 1
          fi
          
          echo "CF_BUCKET=$BUCKET" >> $GITHUB_OUTPUT
          echo "Using S3 bucket: $BUCKET"
      - name: Install SAM CLI
        uses: aws-actions/setup-sam@v2
        with:
          version: 1.141.0
          use-installer: true

      - name: Build SAM application
        run: |
          sam build --template template-webapp-lambda.yml
      - name: Check and handle failed stack state
        run: |
          # Check if stack exists and its status
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "STACK_NOT_FOUND")
          
          echo "Current stack status: $STACK_STATUS"
          
          # Handle different stack states
          case "$STACK_STATUS" in
            "STACK_NOT_FOUND")
              echo "‚ÑπÔ∏è Stack does not exist. Will create new stack."
              ;;
            "CREATE_COMPLETE"|"UPDATE_COMPLETE")
              echo "‚ÑπÔ∏è Stack is in healthy state: $STACK_STATUS. Proceeding with deployment."
              ;;
            "ROLLBACK_COMPLETE"|"CREATE_FAILED")
              echo "‚ö†Ô∏è Stack is in failed state: $STACK_STATUS. Deleting stack to allow re-creation..."
              aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }}
              echo "‚è≥ Waiting for stack deletion to complete..."
              aws cloudformation wait stack-delete-complete --stack-name ${{ env.STACK_NAME }}
              echo "‚úÖ Stack deletion completed"
              ;;
            "ROLLBACK_IN_PROGRESS"|"CREATE_IN_PROGRESS"|"UPDATE_IN_PROGRESS"|"DELETE_IN_PROGRESS")
              echo "‚è≥ Stack is in progress state: $STACK_STATUS. Waiting for operation to complete..."
              # Wait for the current operation to complete
              if [[ "$STACK_STATUS" == "ROLLBACK_IN_PROGRESS" ]]; then
                echo "‚è≥ Waiting for rollback to complete..."
                aws cloudformation wait stack-rollback-complete --stack-name ${{ env.STACK_NAME }}
                # After rollback completes, delete the stack
                echo "üßπ Rollback completed. Deleting failed stack..."
                aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }}
                aws cloudformation wait stack-delete-complete --stack-name ${{ env.STACK_NAME }}
                echo "‚úÖ Failed stack cleanup completed"
              elif [[ "$STACK_STATUS" == "CREATE_IN_PROGRESS" ]]; then
                aws cloudformation wait stack-create-complete --stack-name ${{ env.STACK_NAME }}
              elif [[ "$STACK_STATUS" == "UPDATE_IN_PROGRESS" ]]; then
                aws cloudformation wait stack-update-complete --stack-name ${{ env.STACK_NAME }}
              elif [[ "$STACK_STATUS" == "DELETE_IN_PROGRESS" ]]; then
                aws cloudformation wait stack-delete-complete --stack-name ${{ env.STACK_NAME }}
              fi
              ;;
            "UPDATE_ROLLBACK_COMPLETE")
              echo "‚ö†Ô∏è Stack is in UPDATE_ROLLBACK_COMPLETE state. This indicates a failed update that was rolled back."
              echo "‚ÑπÔ∏è Stack is still functional but last update failed. Proceeding with new deployment."
              ;;
            "DELETE_FAILED")
              echo "‚ùå Stack is in DELETE_FAILED state. Manual intervention required."
              echo "   Please manually delete the stack or resolve the deletion issues."
              exit 1
              ;;
            "REVIEW_IN_PROGRESS")
              echo "‚ö†Ô∏è Stack is in REVIEW_IN_PROGRESS state due to failed changeset"
              echo "   Deleting the stack to clean up the failed changeset..."
              aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }}
              echo "‚è≥ Waiting for stack deletion to complete..."
              aws cloudformation wait stack-delete-complete --stack-name ${{ env.STACK_NAME }}
              echo "‚úÖ Stack cleanup completed"
              ;;
            *)
              echo "‚ùå Stack is in unexpected state: $STACK_STATUS"
              echo "   Manual intervention may be required."
              exit 1
              ;;
          esac
      - name: Deploy webapp CloudFormation stack
        run: |
          echo "Using stack name: $STACK_NAME"
          echo "Using environment: $ENVIRONMENT_NAME"
          
          # Final check that stack is in a deployable state
          FINAL_STATUS=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "STACK_NOT_FOUND")
            echo "Final stack status before deployment: $FINAL_STATUS"
          
          # Ensure we're in a deployable state
          case "$FINAL_STATUS" in
            "STACK_NOT_FOUND"|"CREATE_COMPLETE"|"UPDATE_COMPLETE"|"UPDATE_ROLLBACK_COMPLETE")
              echo "‚úÖ Stack is in deployable state: $FINAL_STATUS"
              ;;
            "REVIEW_IN_PROGRESS")
              echo "‚ö†Ô∏è Stack is in REVIEW_IN_PROGRESS state due to failed changeset"
              echo "   Deleting the stack to clean up the failed changeset..."
              aws cloudformation delete-stack --stack-name "$STACK_NAME"
              echo "‚è≥ Waiting for stack deletion to complete..."
              aws cloudformation wait stack-delete-complete --stack-name "$STACK_NAME"
              echo "‚úÖ Stack cleanup completed, proceeding with fresh deployment"
              ;;
            "ROLLBACK_COMPLETE"|"CREATE_FAILED"|"ROLLBACK_IN_PROGRESS"|*"_IN_PROGRESS")
              echo "‚ùå Stack is in non-deployable state: $FINAL_STATUS"
              echo "   This should not happen after our cleanup step. The previous step may have failed."
              exit 1
              ;;
            *)
              echo "‚ö†Ô∏è Stack is in unexpected state: $FINAL_STATUS. Attempting deployment anyway..."
              ;;
          esac
          
          # Validate parameters before deployment
          if [[ -z "${{ steps.db_info.outputs.DB_SECRET_ARN }}" ]]; then
            echo "‚ùå Database secret ARN is empty"
            exit 1
          fi
          
          if [[ -z "${{ steps.db_info.outputs.DB_ENDPOINT }}" ]]; then
            echo "‚ùå Database endpoint is empty"
            exit 1
          fi
          
          if [[ -z "${{ steps.bucket.outputs.CF_BUCKET }}" ]]; then
            echo "‚ùå S3 bucket is empty"
            exit 1
          fi
          
          # Deploy with validated parameters and enhanced error handling
          echo "üöÄ Starting SAM deployment..."
          if ! sam deploy \
            --stack-name "$STACK_NAME" \
            --s3-bucket "${{ steps.bucket.outputs.CF_BUCKET }}" \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              "EnvironmentName=${{ env.ENVIRONMENT_NAME }}" \
              "DatabaseSecretArn=${{ steps.db_info.outputs.DB_SECRET_ARN }}" \
              "DatabaseEndpoint=${{ steps.db_info.outputs.DB_ENDPOINT }}" \
            --no-confirm-changeset \
            --no-fail-on-empty-changeset; then
            
            echo "‚ùå SAM deployment failed. Checking stack status..."
            DEPLOY_STATUS=$(aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --query "Stacks[0].StackStatus" \
              --output text 2>/dev/null || echo "STACK_NOT_FOUND")
            echo "Stack status after failed deployment: $DEPLOY_STATUS"
            
            # If deployment failed and stack is in rollback state, clean it up for next attempt
            if [[ "$DEPLOY_STATUS" == "ROLLBACK_COMPLETE" || "$DEPLOY_STATUS" == "CREATE_FAILED" ]]; then
              echo "üßπ Cleaning up failed deployment for next attempt..."
              aws cloudformation delete-stack --stack-name "$STACK_NAME"
            fi
            
            exit 1
          fi
          
          echo "‚úÖ SAM deployment completed successfully"
          echo "STACK_NAME=$STACK_NAME" >> $GITHUB_OUTPUT
      - name: Get stack outputs
        id: stack_outputs
        run: |
          # Get CloudFormation stack outputs
          FRONTEND_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='FrontendBucketName'].OutputValue" \
            --output text)
          
          CLOUDFRONT_ID=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='CloudFrontDistributionId'].OutputValue" \
            --output text)
          
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='ApiGatewayUrl'].OutputValue" \
            --output text)
            WEBSITE_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='WebsiteURL'].OutputValue" \
            --output text)
          
          # Validate required outputs
          if [[ -z "$FRONTEND_BUCKET" || "$FRONTEND_BUCKET" == "None" ]]; then
            echo "‚ùå Failed to get FrontendBucketName from stack outputs"
            aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --query "Stacks[0].Outputs[].[OutputKey,OutputValue]" \
              --output table
            exit 1
          fi
          
          if [[ -z "$API_URL" || "$API_URL" == "None" ]]; then
            echo "‚ùå Failed to get ApiGatewayUrl from stack outputs"
            echo "This is critical - the frontend needs this URL!"
            aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --query "Stacks[0].Outputs[].[OutputKey,OutputValue]" \
              --output table
            exit 1
          fi
          
          # Extract bucket prefix to avoid secret masking (bucket name contains AWS Account ID)
          # Bucket format: financial-dashboard-frontend-dev-ACCOUNTID
          BUCKET_PREFIX=$(echo "$FRONTEND_BUCKET" | cut -d'-' -f1-4)  # Gets "financial-dashboard-frontend-dev"
          
          # Set outputs (avoiding the full bucket name that contains account ID)
          echo "bucket_prefix=$BUCKET_PREFIX" >> $GITHUB_OUTPUT
          echo "cloudfront_id=$CLOUDFRONT_ID" >> $GITHUB_OUTPUT
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "website_url=$WEBSITE_URL" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Stack outputs retrieved successfully:"
          echo "  Bucket prefix: $BUCKET_PREFIX"
          echo "  CloudFront ID: $CLOUDFRONT_ID"
          echo "  API URL: $API_URL"
          echo "  Website URL: $WEBSITE_URL"
      
      - name: Check if database initialization is needed
        id: check_db_changes
        run: |
          echo "üîç Checking if database initialization is needed..."
          
          # Check if database-related files have changed
          DB_FILES_CHANGED="false"
          
          # Files that trigger database initialization
          DB_TRIGGER_FILES=(
            "webapp/lambda/utils/database.js"
            "webapp-db-init.js"
            "Dockerfile.webapp-db-init"
          )
          
          # Check if any DB files changed in the last commit
          for file in "${DB_TRIGGER_FILES[@]}"; do
            if git diff --name-only HEAD~1 HEAD | grep -q "$file"; then
              echo "üìù Database file changed: $file"
              DB_FILES_CHANGED="true"
              break
            fi
          done
          
          # Also check if this is the first deployment (no previous commit)
          if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
            echo "üÜï First deployment - database initialization required"
            DB_FILES_CHANGED="true"
          fi
          
          # Check if template changed (indicates stack recreation)
          if git diff --name-only HEAD~1 HEAD | grep -q "template-webapp-lambda.yml"; then
            echo "üîÑ Webapp template changed - database initialization may be needed"
            DB_FILES_CHANGED="true"
          fi
          
          echo "db_init_needed=$DB_FILES_CHANGED" >> $GITHUB_OUTPUT
          
          if [ "$DB_FILES_CHANGED" = "true" ]; then
            echo "‚úÖ Database initialization will be triggered"
          else
            echo "‚è≠Ô∏è  No database changes detected - skipping initialization"
          fi

      - name: Initialize Database Tables via ECS Task
        if: steps.check_db_changes.outputs.db_init_needed == 'true'
        run: |
          echo "üóÑÔ∏è Initializing database tables via ECS task..."
          
          # Get the task definition ARN from the stack
          TASK_DEF_ARN=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='DatabaseInitTaskDefArn'].OutputValue" \
            --output text)
          
          if [[ -z "$TASK_DEF_ARN" || "$TASK_DEF_ARN" == "None" ]]; then
            echo "‚ùå Failed to get database init task definition ARN from stack"
            exit 1
          fi
          
          echo "Using task definition: $TASK_DEF_ARN"
          
          # Get infrastructure info
          CLUSTER_ARN=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksApp-ClusterArn'].Value" \
            --output text)
          SUBNET_1=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksCore-PublicSubnet1Id'].Value" \
            --output text)
          SUBNET_2=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksCore-PublicSubnet2Id'].Value" \
            --output text)
          SECURITY_GROUP=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksApp-EcsTasksSecurityGroupId'].Value" \
            --output text)
          
          # Run the ECS task
          echo "üéØ Running database initialization ECS task..."
          
          TASK_ARN=$(aws ecs run-task \
            --cluster "$CLUSTER_ARN" \
            --task-definition "$TASK_DEF_ARN" \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_1,$SUBNET_2],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
            --query 'tasks[0].taskArn' \
            --output text)
          
          if [[ -z "$TASK_ARN" || "$TASK_ARN" == "None" ]]; then
            echo "‚ùå Failed to start ECS task"
            exit 1
          fi
          
          echo "Started ECS task: $TASK_ARN"
          
          # Wait for task to complete
          echo "‚è≥ Waiting for task to complete..."
          aws ecs wait tasks-stopped \
            --cluster "$CLUSTER_ARN" \
            --tasks "$TASK_ARN" \
            --cli-read-timeout 3600 \
            --cli-connect-timeout 60
          
          # Get task details for debugging
          echo "üìã Getting task details..."
          TASK_DETAILS=$(aws ecs describe-tasks \
            --cluster "$CLUSTER_ARN" \
            --tasks "$TASK_ARN" \
            --output json)
          
          # Log task status for debugging
          TASK_STATUS=$(echo "$TASK_DETAILS" | jq -r '.tasks[0].lastStatus // "unknown"')
          STOP_REASON=$(echo "$TASK_DETAILS" | jq -r '.tasks[0].stopCode // "N/A"')
          CONTAINER_STATUS=$(echo "$TASK_DETAILS" | jq -r '.tasks[0].containers[0].lastStatus // "unknown"')
          echo "Task status: $TASK_STATUS"
          echo "Container status: $CONTAINER_STATUS"
          echo "Stop reason: $STOP_REASON"
          
          # Try to get logs from CloudWatch if task failed
          TASK_DEF_FAMILY=$(echo "$TASK_DETAILS" | jq -r '.tasks[0].taskDefinitionArn' | awk -F'/' '{print $2}' | awk -F':' '{print $1}')
          TASK_ID=$(echo "$TASK_ARN" | awk -F'/' '{print $NF}')
          LOG_GROUP="/ecs/$TASK_DEF_FAMILY"
          LOG_STREAM="ecs/$TASK_DEF_FAMILY/$TASK_ID"
          
          echo "üìÑ Attempting to retrieve CloudWatch logs..."
          aws logs get-log-events \
            --log-group-name "$LOG_GROUP" \
            --log-stream-name "$LOG_STREAM" \
            --limit 50 \
            --output text \
            --query 'events[*].message' 2>/dev/null || echo "Could not retrieve logs"
          
          # Check exit code
          EXIT_CODE=$(echo "$TASK_DETAILS" | jq -r '.tasks[0].containers[0].exitCode // "None"')
          
          # Handle cases where exit code might be None or empty
          if [[ -z "$EXIT_CODE" || "$EXIT_CODE" == "None" ]]; then
            echo "‚ùå Database initialization failed - task did not complete properly (no exit code)"
            exit 1
          elif [[ ! "$EXIT_CODE" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Database initialization failed - invalid exit code: $EXIT_CODE"
            exit 1
          elif [ "$EXIT_CODE" -eq 0 ]; then
            echo "‚úÖ Database initialization completed successfully"
          else
            echo "‚ùå Database initialization failed with exit code: $EXIT_CODE"
            exit 1
          fi
################################################################################
# 3) Build and deploy Frontend                                                 #
################################################################################
  deploy_frontend:
    name: Deploy Frontend to S3
    needs: [filter, deploy_infrastructure]
    if: ${{ needs.filter.outputs.any == 'true' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: webapp/frontend/package-lock.json

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region:        ${{ env.AWS_REGION }}
          role-to-assume:    ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}

      - name: Install Frontend dependencies
        working-directory: webapp/frontend
        run: |
          npm ci
          echo "Frontend dependencies installed"
      - name: Test Frontend
        working-directory: webapp/frontend
        env:
          API_URL: ${{ needs.deploy_infrastructure.outputs.api_url }}
        run: |
          # Run tests if available
          if npm run test:unit --if-present 2>/dev/null; then
            echo "Frontend unit tests passed"
          else
            echo "No unit tests found or configured, skipping"
          fi
          
          # Basic lint check if available
          if npm run lint --if-present 2>/dev/null; then
            echo "Frontend lint check passed"
          else
            echo "No lint script found, skipping"
          fi
      - name: Get Cognito configuration
        id: cognito_config
        run: |
          STACK_NAME="${{ needs.deploy_infrastructure.outputs.stack_name }}"
          
          # Get Cognito configuration from CloudFormation outputs
          USER_POOL_ID=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='UserPoolId'].OutputValue" \
            --output text 2>/dev/null || echo "")
          
          CLIENT_ID=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='UserPoolClientId'].OutputValue" \
            --output text 2>/dev/null || echo "")
          
          COGNITO_DOMAIN=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='UserPoolDomain'].OutputValue" \
            --output text 2>/dev/null || echo "")
          
          WEBSITE_URL="${{ needs.deploy_infrastructure.outputs.website_url }}"
          
          # Set outputs for use in build step
          echo "user_pool_id=$USER_POOL_ID" >> $GITHUB_OUTPUT
          echo "client_id=$CLIENT_ID" >> $GITHUB_OUTPUT
          echo "cognito_domain=$COGNITO_DOMAIN" >> $GITHUB_OUTPUT
          echo "website_url=$WEBSITE_URL" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Cognito configuration retrieved:"
          echo "  User Pool ID: $USER_POOL_ID"
          echo "  Client ID: $CLIENT_ID"
          echo "  Cognito Domain: $COGNITO_DOMAIN"
          echo "  Website URL: $WEBSITE_URL"

      - name: Build Frontend
        working-directory: webapp/frontend
        env:
          API_URL: ${{ needs.deploy_infrastructure.outputs.api_url }}
          VITE_API_URL: ${{ needs.deploy_infrastructure.outputs.api_url }}
          VITE_COGNITO_USER_POOL_ID: ${{ steps.cognito_config.outputs.user_pool_id }}
          VITE_COGNITO_CLIENT_ID: ${{ steps.cognito_config.outputs.client_id }}
          VITE_AWS_REGION: ${{ env.AWS_REGION }}
          VITE_COGNITO_DOMAIN: ${{ steps.cognito_config.outputs.cognito_domain }}
          VITE_COGNITO_REDIRECT_SIGN_IN: ${{ steps.cognito_config.outputs.website_url }}
          VITE_COGNITO_REDIRECT_SIGN_OUT: ${{ steps.cognito_config.outputs.website_url }}
        run: |
          echo "üîß Environment variables for build:"
          echo "API_URL: $API_URL"
          echo "VITE_API_URL: $VITE_API_URL"
          echo "VITE_COGNITO_USER_POOL_ID: $VITE_COGNITO_USER_POOL_ID"
          echo "VITE_COGNITO_CLIENT_ID: $VITE_COGNITO_CLIENT_ID"
          echo "VITE_AWS_REGION: $VITE_AWS_REGION"
          echo "VITE_COGNITO_DOMAIN: $VITE_COGNITO_DOMAIN"
          echo "Node environment: $NODE_ENV"
          
          # Verify the API URL is not empty
          if [[ -z "$VITE_API_URL" ]]; then
            echo "‚ùå VITE_API_URL is empty! This will cause the frontend to fail."
            echo "Available outputs from deploy_infrastructure:"
            echo "  api_url: '${{ needs.deploy_infrastructure.outputs.api_url }}'"
            exit 1
          fi
          
          # Verify Cognito configuration
          if [[ -z "$VITE_COGNITO_USER_POOL_ID" || -z "$VITE_COGNITO_CLIENT_ID" ]]; then
            echo "‚ö†Ô∏è  Cognito configuration is incomplete - authentication may not work"
            echo "  User Pool ID: '$VITE_COGNITO_USER_POOL_ID'"
            echo "  Client ID: '$VITE_COGNITO_CLIENT_ID'"
          else
            echo "‚úÖ Cognito configuration looks complete"
          fi
          
          # Show what's in the .env file for debugging
          echo "üìÑ Current .env content (if exists):"
          cat .env 2>/dev/null || echo "No .env file found"
          
          # Create/update .env file with all configuration
          echo "VITE_API_URL=$VITE_API_URL" > .env
          echo "VITE_COGNITO_USER_POOL_ID=$VITE_COGNITO_USER_POOL_ID" >> .env
          echo "VITE_COGNITO_CLIENT_ID=$VITE_COGNITO_CLIENT_ID" >> .env
          echo "VITE_AWS_REGION=$VITE_AWS_REGION" >> .env
          echo "VITE_COGNITO_DOMAIN=$VITE_COGNITO_DOMAIN" >> .env
          echo "VITE_COGNITO_REDIRECT_SIGN_IN=$VITE_COGNITO_REDIRECT_SIGN_IN" >> .env
          echo "VITE_COGNITO_REDIRECT_SIGN_OUT=$VITE_COGNITO_REDIRECT_SIGN_OUT" >> .env
          echo "VITE_SERVERLESS=true" >> .env
          echo "VITE_ENVIRONMENT=production" >> .env
          
          echo "üìù Created .env file with:"
          cat .env
          # Also create runtime config file for dynamic loading
          mkdir -p public
          echo "// Runtime configuration - dynamically set during deployment" > public/config.js
          echo "window.__CONFIG__ = {" >> public/config.js
          echo "  API_URL: '$VITE_API_URL'," >> public/config.js
          echo "  ENVIRONMENT: '${{ needs.deploy_infrastructure.outputs.environment }}'," >> public/config.js
          echo "  VERSION: '$(date +%Y%m%d-%H%M%S)'," >> public/config.js
          echo "  BUILD_TIME: '$(date -u +%Y-%m-%dT%H:%M:%SZ)'," >> public/config.js
          echo "  COGNITO: {" >> public/config.js
          echo "    USER_POOL_ID: '$VITE_COGNITO_USER_POOL_ID'," >> public/config.js
          echo "    CLIENT_ID: '$VITE_COGNITO_CLIENT_ID'," >> public/config.js
          echo "    REGION: '$VITE_AWS_REGION'," >> public/config.js
          echo "    DOMAIN: '$VITE_COGNITO_DOMAIN'," >> public/config.js
          echo "    REDIRECT_SIGN_IN: '$VITE_COGNITO_REDIRECT_SIGN_IN'," >> public/config.js
          echo "    REDIRECT_SIGN_OUT: '$VITE_COGNITO_REDIRECT_SIGN_OUT'" >> public/config.js
          echo "  }" >> public/config.js
          echo "};" >> public/config.js
          echo "console.log('Runtime config loaded:', window.__CONFIG__);" >> public/config.js
          echo "üìù Created runtime config:"
          cat public/config.js
          
          npm run build
          echo "‚úÖ Frontend build completed"
      - name: Deploy Frontend to S3
        working-directory: webapp/frontend
        run: |
          # Reconstruct bucket name from prefix and AWS Account ID
          BUCKET_PREFIX="${{ needs.deploy_infrastructure.outputs.bucket_prefix }}"
          AWS_ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}"
          BUCKET_NAME="${BUCKET_PREFIX}-${AWS_ACCOUNT_ID}"
          
          # Validate bucket components
          if [[ -z "$BUCKET_PREFIX" ]]; then
            echo "‚ùå Bucket prefix is empty!"
            echo "Available outputs from deploy_infrastructure job:"
            echo "  bucket_prefix: '${{ needs.deploy_infrastructure.outputs.bucket_prefix }}'"
            echo "  cloudfront_id: '${{ needs.deploy_infrastructure.outputs.cloudfront_id }}'"
            echo "  api_url: '${{ needs.deploy_infrastructure.outputs.api_url }}'"
            echo "  website_url: '${{ needs.deploy_infrastructure.outputs.website_url }}'"
            exit 1
          fi
          
          if [[ -z "$AWS_ACCOUNT_ID" ]]; then
            echo "‚ùå AWS Account ID is not set!"
            exit 1
          fi
          
          echo "Using bucket: $BUCKET_NAME"
          
          # Verify bucket exists
          if ! aws s3 ls "s3://$BUCKET_NAME" >/dev/null 2>&1; then
            echo "‚ùå S3 bucket '$BUCKET_NAME' does not exist or is not accessible"
            exit 1
          fi
          
          # Sync frontend files to S3
          aws s3 sync dist/ s3://"$BUCKET_NAME"/ \
            --delete \
            --cache-control "public, max-age=31536000" \
            --exclude "*.html" \
            --exclude "service-worker.js"
          
          # Upload HTML files with shorter cache
          aws s3 sync dist/ s3://"$BUCKET_NAME"/ \
            --cache-control "public, max-age=0, must-revalidate" \
            --include "*.html" \
            --include "service-worker.js"
          
          echo "Frontend deployed to S3 bucket: $BUCKET_NAME"
      - name: Invalidate CloudFront cache
        run: |
          DISTRIBUTION_ID="${{ needs.deploy_infrastructure.outputs.cloudfront_id }}"
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "$DISTRIBUTION_ID" \
            --paths "/*" \
            --query "Invalidation.Id" \
            --output text)
          
          echo "CloudFront invalidation created: $INVALIDATION_ID"
          echo "Distribution ID: $DISTRIBUTION_ID"
################################################################################
# 5) Post-deployment verification                                              #
################################################################################
  verify_deployment:
    name: Verify deployment
    needs: [setup, deploy_infrastructure, deploy_frontend]
    if: ${{ always() && needs.deploy_infrastructure.result == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region:        ${{ env.AWS_REGION }}
          role-to-assume:    ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}

      - name: Test API endpoint with diagnostics
        run: |
          API_URL="${{ needs.deploy_infrastructure.outputs.api_url }}"
          
          echo "üîç Testing API endpoints with detailed diagnostics..."
          echo "Full API URL: $API_URL"
          echo ""
          
          # Test root endpoint first
          echo "1. Testing root endpoint..."
          ROOT_RESPONSE=$(curl -s "$API_URL/" 2>&1 || echo "CURL_FAILED")
          echo "Root response: $ROOT_RESPONSE"
          echo ""
          
          # Test health endpoint
          echo "2. Testing health endpoint..."
          HEALTH_RESPONSE=$(curl -s "$API_URL/health" 2>&1 || echo "CURL_FAILED")
          echo "Health response: $HEALTH_RESPONSE"
          echo ""
          
          # Test quick health endpoint (no DB required)
          echo "3. Testing quick health endpoint (no DB required)..."
          QUICK_HEALTH_RESPONSE=$(curl -s "$API_URL/health?quick=true" 2>&1 || echo "CURL_FAILED")
          echo "Quick health response: $QUICK_HEALTH_RESPONSE"
          echo ""
          
          # Test stocks endpoint (requires DB)
          echo "4. Testing stocks endpoint (requires database)..."
          STOCKS_RESPONSE=$(curl -s "$API_URL/api/stocks?limit=1" 2>&1 || echo "CURL_FAILED")
          echo "Stocks response (first 500 chars): ${STOCKS_RESPONSE:0:500}"
          echo ""
          
          # Test diagnostics endpoint for detailed configuration info
          echo "5. Testing diagnostics endpoint (detailed configuration)..."
          DIAGNOSTICS_RESPONSE=$(curl -s "$API_URL/api/diagnostics" 2>&1 || echo "CURL_FAILED")
          echo "Diagnostics response: $DIAGNOSTICS_RESPONSE"
          echo ""
          
          # Analyze responses
          echo "üî¨ Response Analysis:"
          
          if echo "$ROOT_RESPONSE" | grep -q "Financial Dashboard API"; then
            echo "‚úÖ Root endpoint: Lambda is running and responding"
          elif echo "$ROOT_RESPONSE" | grep -q "Internal server error"; then
            echo "‚ùå Root endpoint: Lambda has internal error (likely config issue)"
          else
            echo "‚ö†Ô∏è  Root endpoint: Unexpected response - Lambda may not be deployed correctly"
          fi
          
          if echo "$QUICK_HEALTH_RESPONSE" | grep -q "status"; then
            echo "‚úÖ Quick health: Basic Lambda functionality working"
          elif echo "$QUICK_HEALTH_RESPONSE" | grep -q "Internal server error"; then
            echo "‚ùå Quick health: Lambda configuration issue (not database-related)"
          else
            echo "‚ö†Ô∏è  Quick health: Unexpected response"
          fi
          
          if echo "$STOCKS_RESPONSE" | grep -q "success.*true"; then
            echo "‚úÖ Database connectivity: Working correctly"
          elif echo "$STOCKS_RESPONSE" | grep -q "Internal server error"; then
            echo "‚ùå Database connectivity: Lambda cannot connect to database"
          elif echo "$STOCKS_RESPONSE" | grep -q "Database not available"; then
            echo "‚ùå Database connectivity: Database connection failed"
          else
            echo "‚ö†Ô∏è  Database connectivity: Unexpected response"
          fi
          
          if echo "$DIAGNOSTICS_RESPONSE" | grep -q "HEALTHY"; then
            echo "‚úÖ Configuration: All diagnostics passed"
          elif echo "$DIAGNOSTICS_RESPONSE" | grep -q "ISSUES_FOUND"; then
            echo "‚ùå Configuration: Issues detected - check diagnostics for details"
          elif echo "$DIAGNOSTICS_RESPONSE" | grep -q "Internal server error"; then
            echo "‚ùå Configuration: Lambda has fundamental configuration issues"
          else
            echo "‚ö†Ô∏è  Configuration: Diagnostics endpoint not responding correctly"
          fi
          
          echo ""
          echo "üìã Summary:"
          echo "If you see 'Internal server error' responses, the Lambda likely has configuration issues."
          echo "Common causes: Missing environment variables, IAM permissions, or VPC networking."
          echo "Check the diagnostics response above for specific configuration details and recommendations."
      - name: Test website
        run: |
          WEBSITE_URL="${{ needs.deploy_infrastructure.outputs.website_url }}"
          
          echo "Testing website availability..."
          if curl -f -s "$WEBSITE_URL" > /dev/null; then
            echo "‚úÖ Website is accessible"
          else
            echo "‚ö†Ô∏è  Website check failed, but deployment will continue"
          fi
      - name: Deployment summary
        env:
          STACK_NAME: ${{ needs.setup.outputs.stack_name }}
        run: |
          echo "üéâ Webapp deployment completed!"
          echo ""
          echo "üìä Deployment Summary:"
          echo "  ‚Ä¢ Website URL: ${{ needs.deploy_infrastructure.outputs.website_url }}"
          echo "  ‚Ä¢ API URL: ${{ needs.deploy_infrastructure.outputs.api_url }}"
          echo "  ‚Ä¢ Bucket Prefix: ${{ needs.deploy_infrastructure.outputs.bucket_prefix }}"
          echo "  ‚Ä¢ CloudFront ID: ${{ needs.deploy_infrastructure.outputs.cloudfront_id }}"
          echo ""
          echo "üîß Stack Status:"
          if [ -n "$STACK_NAME" ]; then
            aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --query "Stacks[0].StackStatus" \
              --output text
          else
            echo "Stack name not available"
          fi
################################################################################
# 6) Cleanup on failure                                                        #
################################################################################
  cleanup_on_failure:
    name: Cleanup failed deployment
    needs: [deploy_infrastructure, deploy_frontend]
    if: ${{ failure() && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest

    steps:      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region:        ${{ env.AWS_REGION }}
          role-to-assume:    ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}
      
      - name: Check stack status and cleanup if needed
        run: |
          STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo NOT_FOUND)
          
          echo "Stack status: $STATUS"
          
          if [[ "$STATUS" == "ROLLBACK_COMPLETE" || "$STATUS" == "CREATE_FAILED" ]]; then
            echo "Cleaning up failed stack..."
            aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }}
            echo "Stack deletion initiated"
          else
            echo "Stack is in a stable state, no cleanup needed"
          fi
