name: deploy-webapp

on:
  push:
    branches:
      - '*'
    paths:
      - 'webapp/**'
      - 'template-webapp-lambda.yml'
      - '.github/workflows/deploy-webapp.yml'
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  AWS_ROLE_ARN: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsDeployRole
  AWS_ROLE_SESSION: github-deploy
  NODE_VERSION: '18.x'

jobs:
################################################################################
# 1) Determine environment based on branch                                     #
################################################################################
  setup:
    name: Setup environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      stack_name: ${{ steps.env.outputs.stack_name }}
    steps:
      - name: Determine environment
        id: env
        run: |
          # Force everything to dev environment for now
          echo "environment=dev" >> $GITHUB_OUTPUT
          echo "stack_name=stocks-webapp-dev" >> $GITHUB_OUTPUT
          echo "Deploying to environment: dev"
################################################################################
# 2) Detect changed components                                                 #
################################################################################
  filter:
    name: Detect changed components
    needs: setup
    runs-on: ubuntu-latest
    outputs:
      webapp:     ${{ steps.paths.outputs.webapp }}
      lambda:     ${{ steps.paths.outputs.lambda }}
      frontend:   ${{ steps.paths.outputs.frontend }}
      template:   ${{ steps.paths.outputs.template }}
      any:        ${{ steps.any.outputs.any }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - id: paths
        name: Which files changed?
        uses: dorny/paths-filter@v2
        with:
          base: ${{ github.event.before != '0000000000000000000000000000000000000000' && github.event.before || github.sha }}
          filters: |
            webapp:
              - 'webapp/**'
            lambda:
              - 'webapp/lambda/**'
              - 'webapp/backend/**'
            frontend:
              - 'webapp/frontend/**'
            template:
              - 'template-webapp-lambda.yml'
              - '.github/workflows/deploy-webapp.yml'
      - id: any
        name: Any relevant changes?
        run: |
          if [[ "${{ steps.paths.outputs.webapp }}" == "true" || "${{ steps.paths.outputs.lambda }}" == "true" || "${{ steps.paths.outputs.frontend }}" == "true" || "${{ steps.paths.outputs.template }}" == "true" ]]; then
            echo "any=true" >> $GITHUB_OUTPUT
          else
            echo "any=false" >> $GITHUB_OUTPUT
          fi
################################################################################
# 3) Run integration tests                                                     #
################################################################################
  integration_tests:
    name: Run integration tests
    needs: [setup, filter]
    if: ${{ needs.filter.outputs.any == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT_NAME: ${{ needs.setup.outputs.environment }}
      NODE_ENV: test
      TEST_API_URL: https://jh28jhdp01.execute-api.us-east-1.amazonaws.com/dev
      TEST_DB_HOST: ${{ secrets.TEST_DB_HOST }}
      TEST_DB_USER: ${{ secrets.TEST_DB_USER }}
      TEST_DB_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
      TEST_DB_NAME: ${{ secrets.TEST_DB_NAME }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: webapp/frontend/package-lock.json

      - name: Install frontend dependencies
        run: |
          cd webapp/frontend
          npm ci

      - name: Install backend dependencies
        run: |
          cd webapp/lambda
          npm ci

      - name: 🧪 Run frontend integration tests with comprehensive logging
        run: |
          echo "📱 FRONTEND INTEGRATION TESTS STARTING"
          echo "=================================================="
          echo "🕒 Start Time: $(date)"
          echo "📍 Working Directory: $(pwd)/webapp/frontend"
          echo "🔧 Node Version: $(node --version)"
          echo "📦 NPM Version: $(npm --version)"
          echo ""
          
          cd webapp/frontend
          echo "📋 Package.json test scripts:"
          npm run | grep test: || echo "No test scripts found"
          echo ""
          
          echo "📁 Test Directory Structure:"
          find src/tests -name "*.test.js" -o -name "*.test.jsx" | head -20 || echo "No test files found"
          echo ""
          
          echo "🚀 EXECUTING FRONTEND INTEGRATION TESTS..."
          echo "Command: npm run test:integration"
          echo "=========================================="
          
          # Capture both stdout and stderr with timestamps
          if npm run test:integration 2>&1 | while IFS= read -r line; do echo "[$(date '+%H:%M:%S')] $line"; done; then
            FRONTEND_EXIT_CODE=0
            echo ""
            echo "✅ FRONTEND INTEGRATION TESTS COMPLETED SUCCESSFULLY"
          else
            FRONTEND_EXIT_CODE=$?
            echo ""
            echo "❌ FRONTEND INTEGRATION TESTS FAILED (Exit Code: $FRONTEND_EXIT_CODE)"
            echo "⚠️ Continuing deployment despite test failures for debugging purposes"
          fi
          
          echo ""
          echo "📊 Frontend Test Summary:"
          echo "Exit Code: $FRONTEND_EXIT_CODE"
          echo "End Time: $(date)"
          echo "Duration: $SECONDS seconds"
          echo "=================================================="
        continue-on-error: true

      - name: 🔧 Run backend integration tests with comprehensive logging
        run: |
          echo "🖥️ BACKEND INTEGRATION TESTS STARTING"
          echo "=================================================="
          echo "🕒 Start Time: $(date)"
          echo "📍 Working Directory: $(pwd)/webapp/lambda"
          echo "🔧 Node Version: $(node --version)"
          echo "📦 NPM Version: $(npm --version)"
          echo ""
          
          cd webapp/lambda
          echo "📋 Package.json test scripts:"
          npm run | grep test: || echo "No test scripts found"
          echo ""
          
          echo "📁 Test Directory Structure:"
          find tests -name "*.test.js" | head -20 || echo "No test files found"
          echo ""
          
          echo "🗄️ Database Configuration Check:"
          echo "TEST_DB_HOST: ${TEST_DB_HOST:-'not set'}"
          echo "TEST_DB_USER: ${TEST_DB_USER:-'not set'}"
          echo "TEST_DB_NAME: ${TEST_DB_NAME:-'not set'}"
          echo "TEST_API_URL: ${TEST_API_URL:-'not set'}"
          echo ""
          
          echo "🚀 EXECUTING BACKEND INTEGRATION TESTS..."
          echo "Command: npm run test:integration"
          echo "=========================================="
          
          # Capture both stdout and stderr with timestamps
          if npm run test:integration 2>&1 | while IFS= read -r line; do echo "[$(date '+%H:%M:%S')] $line"; done; then
            BACKEND_EXIT_CODE=0
            echo ""
            echo "✅ BACKEND INTEGRATION TESTS COMPLETED SUCCESSFULLY"
          else
            BACKEND_EXIT_CODE=$?
            echo ""
            echo "❌ BACKEND INTEGRATION TESTS FAILED (Exit Code: $BACKEND_EXIT_CODE)"
            echo "⚠️ Continuing deployment despite test failures for debugging purposes"
          fi
          
          echo ""
          echo "📊 Backend Test Summary:"
          echo "Exit Code: $BACKEND_EXIT_CODE"
          echo "End Time: $(date)"
          echo "Duration: $SECONDS seconds"
          echo "=================================================="
        continue-on-error: true

      - name: 📊 Generate comprehensive integration test report
        run: |
          echo "📋 GENERATING COMPREHENSIVE TEST REPORT"
          echo "=================================================="
          echo "🕒 Report Generation Time: $(date)"
          echo ""
          
          # Create detailed markdown report
          cat > integration-test-results.md << 'EOF'
          # 🧪 Integration Test Execution Report
          
          **Generated:** $(date)  
          **Environment:** ${{ needs.setup.outputs.environment }}  
          **Workflow:** ${{ github.workflow }}  
          **Run ID:** ${{ github.run_id }}  
          **Commit:** ${{ github.sha }}  
          
          ## 📱 Frontend Integration Tests
          
          **Working Directory:** `webapp/frontend`  
          **Test Command:** `npm run test:integration`  
          **Node Version:** $(node --version)  
          
          ### Test Files Found:
          ```
          $(cd webapp/frontend && find src/tests -name "*.test.js" -o -name "*.test.jsx" | head -10 || echo "No test files found")
          ```
          
          ### Frontend Dependencies:
          ```
          $(cd webapp/frontend && npm list --depth=0 | grep -E "(vitest|playwright|testing)" || echo "No test dependencies found")
          ```
          
          ## 🔧 Backend Integration Tests
          
          **Working Directory:** `webapp/lambda`  
          **Test Command:** `npm run test:integration`  
          **Node Version:** $(node --version)  
          
          ### Test Files Found:
          ```
          $(cd webapp/lambda && find tests -name "*.test.js" | head -10 || echo "No test files found")
          ```
          
          ### Backend Dependencies:
          ```
          $(cd webapp/lambda && npm list --depth=0 | grep -E "(jest|supertest)" || echo "No test dependencies found")
          ```
          
          ## 🌐 Environment Configuration
          
          - **API URL:** ${TEST_API_URL}
          - **Database Host:** ${TEST_DB_HOST:-'not configured'}
          - **Database Name:** ${TEST_DB_NAME:-'not configured'}
          - **Node Environment:** ${NODE_ENV}
          
          ## 📁 Test Results Location
          
          - Frontend Results: `webapp/frontend/test-results/`
          - Backend Results: `webapp/lambda/test-results/`
          - Coverage Reports: Available in individual directories
          
          ## 🔍 Troubleshooting Information
          
          If tests fail, check:
          1. Database connectivity (connection strings, credentials)
          2. API endpoint accessibility (network, authentication)
          3. Test environment setup (dependencies, configuration)
          4. Test data cleanup (previous test residue)
          
          ## 📊 System Information
          
          - **OS:** $(uname -a)
          - **Memory:** $(free -h | head -2)
          - **Disk Space:** $(df -h / | tail -1)
          - **Network:** $(ping -c 1 8.8.8.8 > /dev/null && echo "Connected" || echo "No connectivity")
          
          EOF
          
          echo "✅ Test report generated successfully"
          echo ""
          echo "📄 Report Contents:"
          echo "==================="
          cat integration-test-results.md
          echo "==================="
          echo ""
          echo "📊 Integration Test Execution Summary:"
          echo "- Report file: integration-test-results.md"
          echo "- Frontend test directory: webapp/frontend/src/tests/"
          echo "- Backend test directory: webapp/lambda/tests/"
          echo "- Test artifacts will be uploaded for 30 days"
          echo "=================================================="

      - name: 📤 Upload comprehensive test artifacts and logs
        if: always()
        run: |
          echo "📤 UPLOADING TEST ARTIFACTS AND LOGS"
          echo "=================================================="
          echo "🕒 Upload Time: $(date)"
          echo ""
          
          # Create artifacts directory structure
          mkdir -p test-artifacts/{frontend,backend,reports,logs}
          
          echo "📁 Creating comprehensive artifact package..."
          
          # Copy frontend results if they exist
          if [ -d "webapp/frontend/test-results" ]; then
            cp -r webapp/frontend/test-results/* test-artifacts/frontend/ 2>/dev/null || echo "No frontend test results to copy"
            echo "✅ Frontend test results copied"
          else
            echo "⚠️ No frontend test-results directory found"
          fi
          
          # Copy backend results if they exist
          if [ -d "webapp/lambda/test-results" ]; then
            cp -r webapp/lambda/test-results/* test-artifacts/backend/ 2>/dev/null || echo "No backend test results to copy"
            echo "✅ Backend test results copied"
          else
            echo "⚠️ No backend test-results directory found"
          fi
          
          # Copy reports
          cp integration-test-results.md test-artifacts/reports/ 2>/dev/null || echo "⚠️ No integration test report found"
          
          # Generate system diagnostics
          echo "🔍 Generating system diagnostics..."
          cat > test-artifacts/logs/system-diagnostics.log << 'DIAG_EOF'
          INTEGRATION TEST SYSTEM DIAGNOSTICS
          ===================================
          
          Timestamp: $(date)
          Workflow Run: ${{ github.run_id }}
          Commit: ${{ github.sha }}
          
          SYSTEM INFORMATION:
          OS: $(uname -a)
          Node Version: $(node --version)
          NPM Version: $(npm --version)
          
          MEMORY USAGE:
          $(free -h)
          
          DISK USAGE:
          $(df -h /)
          
          NETWORK CONNECTIVITY:
          API Endpoint Test: $(curl -s -o /dev/null -w "%{http_code}" ${TEST_API_URL}/health || echo "FAILED")
          DNS Resolution: $(nslookup google.com || echo "FAILED")
          
          ENVIRONMENT VARIABLES:
          NODE_ENV: ${NODE_ENV}
          TEST_API_URL: ${TEST_API_URL}
          TEST_DB_HOST: ${TEST_DB_HOST:-'not set'}
          TEST_DB_NAME: ${TEST_DB_NAME:-'not set'}
          
          FRONTEND PACKAGE INFO:
          $(cd webapp/frontend && npm list --depth=0 | head -20 || echo "No package info available")
          
          BACKEND PACKAGE INFO:
          $(cd webapp/lambda && npm list --depth=0 | head -20 || echo "No package info available")
          
          DIRECTORY STRUCTURE:
          Frontend Tests: $(find webapp/frontend/src/tests -type f | wc -l) files
          Backend Tests: $(find webapp/lambda/tests -type f | wc -l) files
          
          DIAG_EOF
          
          echo "✅ System diagnostics generated"
          
          # List all artifacts being uploaded
          echo ""
          echo "📋 Artifacts being uploaded:"
          find test-artifacts -type f -exec ls -la {} \; | head -30
          
          echo ""
          echo "📊 Upload Summary:"
          echo "- Total files: $(find test-artifacts -type f | wc -l)"
          echo "- Total size: $(du -sh test-artifacts | cut -f1)"
          echo "- Retention: 30 days"
          echo "=================================================="

      - name: 📦 Upload test artifacts to GitHub
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: integration-test-results-${{ github.run_id }}
          path: |
            test-artifacts/
            integration-test-results.md
            webapp/frontend/test-results/
            webapp/lambda/test-results/
            webapp/frontend/coverage/
            webapp/lambda/coverage/
            webapp/frontend/package.json
            webapp/lambda/package.json
          retention-days: 30
          
      - name: 📊 Integration test completion summary
        if: always()
        run: |
          echo ""
          echo "🎯 INTEGRATION TEST EXECUTION COMPLETED"
          echo "=================================================="
          echo "🕒 Completion Time: $(date)"
          echo "📊 Workflow Status: Integration tests finished"
          echo "📁 Artifacts: Uploaded as 'integration-test-results-${{ github.run_id }}'"
          echo "🔗 Download Link: Available in workflow summary"
          echo "⏭️ Next Step: Proceeding to infrastructure deployment"
          echo "=================================================="

################################################################################
# 4) Deploy webapp infrastructure                                              #
################################################################################
  deploy_infrastructure:
    name: Deploy webapp infrastructure
    needs: [setup, filter, integration_tests]
    if: ${{ needs.filter.outputs.template == 'true' || needs.filter.outputs.any == 'true' }}
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT_NAME: ${{ needs.setup.outputs.environment }}
      STACK_NAME: ${{ needs.setup.outputs.stack_name }}
    outputs:
      bucket_prefix: ${{ steps.stack_outputs.outputs.bucket_prefix }}
      cloudfront_id: ${{ steps.stack_outputs.outputs.cloudfront_id }}
      api_url: ${{ steps.stack_outputs.outputs.api_url }}
      website_url: ${{ steps.stack_outputs.outputs.website_url }}
      environment: ${{ needs.setup.outputs.environment }}
      stack_name: ${{ needs.setup.outputs.stack_name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region:        ${{ env.AWS_REGION }}
          role-to-assume:    ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}

      - name: Get database connection info from stacks
        id: db_info
        run: |
          DB_SECRET_ARN=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksApp-SecretArn'].Value" \
            --output text)
          DB_ENDPOINT=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksApp-DBEndpoint'].Value" \
            --output text)
          
          # Validate that we got the values
          if [[ -z "$DB_SECRET_ARN" || "$DB_SECRET_ARN" == "None" ]]; then
            echo "❌ Failed to get database secret ARN from app stack exports"
            exit 1
          fi
          
          if [[ -z "$DB_ENDPOINT" || "$DB_ENDPOINT" == "None" ]]; then
            echo "❌ Failed to get database endpoint from app stack exports"
            exit 1
          fi
          
          echo "DB_SECRET_ARN=$DB_SECRET_ARN" >> $GITHUB_OUTPUT
          echo "DB_ENDPOINT=$DB_ENDPOINT" >> $GITHUB_OUTPUT
          echo "Using database secret: $DB_SECRET_ARN"
          echo "Using database endpoint: $DB_ENDPOINT"
      
      - name: Get CloudFormation templates bucket from core stack
        id: bucket
        run: |
          BUCKET=$(aws cloudformation list-exports \
            --query "Exports[?Name=='StocksCore-CfTemplatesBucketName'].Value" \
            --output text)
          
          # Validate bucket name
          if [[ -z "$BUCKET" || "$BUCKET" == "None" ]]; then
            echo "❌ Failed to get CloudFormation templates bucket from core stack exports"
            exit 1
          fi
          
          echo "CF_BUCKET=$BUCKET" >> $GITHUB_OUTPUT
          echo "Using S3 bucket: $BUCKET"
      - name: Install SAM CLI
        uses: aws-actions/setup-sam@v2
        with:
          version: 1.141.0
          use-installer: true

      - name: Build SAM application
        run: |
          sam build --template template-webapp-lambda.yml
      - name: Check and handle failed stack state
        run: |
          # Check if stack exists and its status
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "STACK_NOT_FOUND")
          
          echo "Current stack status: $STACK_STATUS"
          
          # Handle different stack states
          case "$STACK_STATUS" in
            "STACK_NOT_FOUND")
              echo "ℹ️ Stack does not exist. Will create new stack."
              ;;
            "CREATE_COMPLETE"|"UPDATE_COMPLETE")
              echo "ℹ️ Stack is in healthy state: $STACK_STATUS. Proceeding with deployment."
              ;;
            "ROLLBACK_COMPLETE"|"CREATE_FAILED")
              echo "⚠️ Stack is in failed state: $STACK_STATUS. Deleting stack to allow re-creation..."
              aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }}
              echo "⏳ Waiting for stack deletion to complete..."
              aws cloudformation wait stack-delete-complete --stack-name ${{ env.STACK_NAME }}
              echo "✅ Stack deletion completed"
              ;;
            "ROLLBACK_IN_PROGRESS"|"CREATE_IN_PROGRESS"|"UPDATE_IN_PROGRESS"|"DELETE_IN_PROGRESS")
              echo "⏳ Stack is in progress state: $STACK_STATUS. Waiting for operation to complete..."
              # Wait for the current operation to complete
              if [[ "$STACK_STATUS" == "ROLLBACK_IN_PROGRESS" ]]; then
                echo "⏳ Waiting for rollback to complete..."
                aws cloudformation wait stack-rollback-complete --stack-name ${{ env.STACK_NAME }}
                # After rollback completes, delete the stack
                echo "🧹 Rollback completed. Deleting failed stack..."
                aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }}
                aws cloudformation wait stack-delete-complete --stack-name ${{ env.STACK_NAME }}
                echo "✅ Failed stack cleanup completed"
              elif [[ "$STACK_STATUS" == "CREATE_IN_PROGRESS" ]]; then
                aws cloudformation wait stack-create-complete --stack-name ${{ env.STACK_NAME }}
              elif [[ "$STACK_STATUS" == "UPDATE_IN_PROGRESS" ]]; then
                aws cloudformation wait stack-update-complete --stack-name ${{ env.STACK_NAME }}
              elif [[ "$STACK_STATUS" == "DELETE_IN_PROGRESS" ]]; then
                aws cloudformation wait stack-delete-complete --stack-name ${{ env.STACK_NAME }}
              fi
              ;;
            "UPDATE_ROLLBACK_COMPLETE")
              echo "⚠️ Stack is in UPDATE_ROLLBACK_COMPLETE state. This indicates a failed update that was rolled back."
              echo "ℹ️ Stack is still functional but last update failed. Proceeding with new deployment."
              ;;
            "DELETE_FAILED")
              echo "❌ Stack is in DELETE_FAILED state. Manual intervention required."
              echo "   Please manually delete the stack or resolve the deletion issues."
              exit 1
              ;;
            "REVIEW_IN_PROGRESS")
              echo "⚠️ Stack is in REVIEW_IN_PROGRESS state due to failed changeset"
              echo "   Deleting the stack to clean up the failed changeset..."
              aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }}
              echo "⏳ Waiting for stack deletion to complete..."
              aws cloudformation wait stack-delete-complete --stack-name ${{ env.STACK_NAME }}
              echo "✅ Stack cleanup completed"
              ;;
            *)
              echo "❌ Stack is in unexpected state: $STACK_STATUS"
              echo "   Manual intervention may be required."
              exit 1
              ;;
          esac
      - name: Deploy webapp CloudFormation stack
        run: |
          echo "Using stack name: $STACK_NAME"
          echo "Using environment: $ENVIRONMENT_NAME"
          
          # Final check that stack is in a deployable state
          FINAL_STATUS=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "STACK_NOT_FOUND")
            echo "Final stack status before deployment: $FINAL_STATUS"
          
          # Ensure we're in a deployable state
          case "$FINAL_STATUS" in
            "STACK_NOT_FOUND"|"CREATE_COMPLETE"|"UPDATE_COMPLETE"|"UPDATE_ROLLBACK_COMPLETE")
              echo "✅ Stack is in deployable state: $FINAL_STATUS"
              ;;
            "REVIEW_IN_PROGRESS")
              echo "⚠️ Stack is in REVIEW_IN_PROGRESS state due to failed changeset"
              echo "   Deleting the stack to clean up the failed changeset..."
              aws cloudformation delete-stack --stack-name "$STACK_NAME"
              echo "⏳ Waiting for stack deletion to complete..."
              aws cloudformation wait stack-delete-complete --stack-name "$STACK_NAME"
              echo "✅ Stack cleanup completed, proceeding with fresh deployment"
              ;;
            "ROLLBACK_COMPLETE"|"CREATE_FAILED"|"ROLLBACK_IN_PROGRESS"|*"_IN_PROGRESS")
              echo "❌ Stack is in non-deployable state: $FINAL_STATUS"
              echo "   This should not happen after our cleanup step. The previous step may have failed."
              exit 1
              ;;
            *)
              echo "⚠️ Stack is in unexpected state: $FINAL_STATUS. Attempting deployment anyway..."
              ;;
          esac
          
          # Validate parameters before deployment
          if [[ -z "${{ steps.db_info.outputs.DB_SECRET_ARN }}" ]]; then
            echo "❌ Database secret ARN is empty"
            exit 1
          fi
          
          if [[ -z "${{ steps.db_info.outputs.DB_ENDPOINT }}" ]]; then
            echo "❌ Database endpoint is empty"
            exit 1
          fi
          
          if [[ -z "${{ steps.bucket.outputs.CF_BUCKET }}" ]]; then
            echo "❌ S3 bucket is empty"
            exit 1
          fi
          
          # Deploy with validated parameters and enhanced error handling
          echo "🚀 Starting SAM deployment..."
          if ! sam deploy \
            --stack-name "$STACK_NAME" \
            --s3-bucket "${{ steps.bucket.outputs.CF_BUCKET }}" \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              "EnvironmentName=${{ env.ENVIRONMENT_NAME }}" \
              "DatabaseSecretArn=${{ steps.db_info.outputs.DB_SECRET_ARN }}" \
              "DatabaseEndpoint=${{ steps.db_info.outputs.DB_ENDPOINT }}" \
            --no-confirm-changeset \
            --no-fail-on-empty-changeset; then
            
            echo "❌ SAM deployment failed. Checking stack status..."
            DEPLOY_STATUS=$(aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --query "Stacks[0].StackStatus" \
              --output text 2>/dev/null || echo "STACK_NOT_FOUND")
            echo "Stack status after failed deployment: $DEPLOY_STATUS"
            
            # If deployment failed and stack is in rollback state, clean it up for next attempt
            if [[ "$DEPLOY_STATUS" == "ROLLBACK_COMPLETE" || "$DEPLOY_STATUS" == "CREATE_FAILED" ]]; then
              echo "🧹 Cleaning up failed deployment for next attempt..."
              aws cloudformation delete-stack --stack-name "$STACK_NAME"
            fi
            
            exit 1
          fi
          
          echo "✅ SAM deployment completed successfully"
          echo "STACK_NAME=$STACK_NAME" >> $GITHUB_OUTPUT
      - name: Get stack outputs
        id: stack_outputs
        run: |
          # Get CloudFormation stack outputs
          FRONTEND_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='FrontendBucketName'].OutputValue" \
            --output text)
          
          CLOUDFRONT_ID=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='CloudFrontDistributionId'].OutputValue" \
            --output text)
          
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='ApiGatewayUrl'].OutputValue" \
            --output text)
            WEBSITE_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='WebsiteURL'].OutputValue" \
            --output text)
          
          # Validate required outputs
          if [[ -z "$FRONTEND_BUCKET" || "$FRONTEND_BUCKET" == "None" ]]; then
            echo "❌ Failed to get FrontendBucketName from stack outputs"
            aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --query "Stacks[0].Outputs[].[OutputKey,OutputValue]" \
              --output table
            exit 1
          fi
          
          if [[ -z "$API_URL" || "$API_URL" == "None" ]]; then
            echo "❌ Failed to get ApiGatewayUrl from stack outputs"
            echo "This is critical - the frontend needs this URL!"
            aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --query "Stacks[0].Outputs[].[OutputKey,OutputValue]" \
              --output table
            exit 1
          fi
          
          # Extract bucket prefix to avoid secret masking (bucket name contains AWS Account ID)
          # Bucket format: financial-dashboard-frontend-dev-ACCOUNTID
          BUCKET_PREFIX=$(echo "$FRONTEND_BUCKET" | cut -d'-' -f1-4)  # Gets "financial-dashboard-frontend-dev"
          
          # Set outputs (avoiding the full bucket name that contains account ID)
          echo "bucket_prefix=$BUCKET_PREFIX" >> $GITHUB_OUTPUT
          echo "cloudfront_id=$CLOUDFRONT_ID" >> $GITHUB_OUTPUT
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "website_url=$WEBSITE_URL" >> $GITHUB_OUTPUT
          
          echo "✅ Stack outputs retrieved successfully:"
          echo "  Bucket prefix: $BUCKET_PREFIX"
          echo "  CloudFront ID: $CLOUDFRONT_ID"
          echo "  API URL: $API_URL"
          echo "  Website URL: $WEBSITE_URL"
################################################################################
# 3) Build and deploy Frontend                                                 #
################################################################################
  deploy_frontend:
    name: Deploy Frontend to S3
    needs: [filter, deploy_infrastructure]
    if: ${{ needs.filter.outputs.any == 'true' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: webapp/frontend/package-lock.json

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region:        ${{ env.AWS_REGION }}
          role-to-assume:    ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}

      - name: Install Frontend dependencies
        working-directory: webapp/frontend
        run: |
          npm ci
          echo "Frontend dependencies installed"
      - name: Test Frontend
        working-directory: webapp/frontend
        env:
          API_URL: ${{ needs.deploy_infrastructure.outputs.api_url }}
        run: |
          # Run tests if available
          if npm run test:unit --if-present 2>/dev/null; then
            echo "Frontend unit tests passed"
          else
            echo "No unit tests found or configured, skipping"
          fi
          
          # Basic lint check if available
          if npm run lint --if-present 2>/dev/null; then
            echo "Frontend lint check passed"
          else
            echo "No lint script found, skipping"
          fi
      - name: Build Frontend
        working-directory: webapp/frontend
        env:
          API_URL: ${{ needs.deploy_infrastructure.outputs.api_url }}
          VITE_API_URL: ${{ needs.deploy_infrastructure.outputs.api_url }}
        run: |
          echo "🔧 Environment variables for build:"
          echo "API_URL: $API_URL"
          echo "VITE_API_URL: $VITE_API_URL"
          echo "Node environment: $NODE_ENV"
          
          # Verify the API URL is not empty
          if [[ -z "$VITE_API_URL" ]]; then
            echo "❌ VITE_API_URL is empty! This will cause the frontend to fail."
            echo "Available outputs from deploy_infrastructure:"
            echo "  api_url: '${{ needs.deploy_infrastructure.outputs.api_url }}'"
            exit 1
          fi
          
          # Show what's in the .env file for debugging
          echo "📄 Current .env content (if exists):"
          cat .env 2>/dev/null || echo "No .env file found"
          # Create/update .env file with the API URL
          echo "VITE_API_URL=$VITE_API_URL" > .env
          echo "📝 Created .env file with:"
          cat .env
          # Also create runtime config file for dynamic loading
          mkdir -p public
          echo "// Runtime configuration - dynamically set during deployment" > public/config.js
          echo "window.__CONFIG__ = {" >> public/config.js
          echo "  API_URL: '$VITE_API_URL'," >> public/config.js
          echo "  ENVIRONMENT: '${{ needs.deploy_infrastructure.outputs.environment }}'," >> public/config.js
          echo "  VERSION: '$(date +%Y%m%d-%H%M%S)'," >> public/config.js
          echo "  BUILD_TIME: '$(date -u +%Y-%m-%dT%H:%M:%SZ)'" >> public/config.js
          echo "};" >> public/config.js
          echo "console.log('Runtime config loaded:', window.__CONFIG__);" >> public/config.js
          echo "📝 Created runtime config:"
          cat public/config.js
          
          npm run build
          echo "✅ Frontend build completed"
      - name: Deploy Frontend to S3
        working-directory: webapp/frontend
        run: |
          # Reconstruct bucket name from prefix and AWS Account ID
          BUCKET_PREFIX="${{ needs.deploy_infrastructure.outputs.bucket_prefix }}"
          AWS_ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}"
          BUCKET_NAME="${BUCKET_PREFIX}-${AWS_ACCOUNT_ID}"
          
          # Validate bucket components
          if [[ -z "$BUCKET_PREFIX" ]]; then
            echo "❌ Bucket prefix is empty!"
            echo "Available outputs from deploy_infrastructure job:"
            echo "  bucket_prefix: '${{ needs.deploy_infrastructure.outputs.bucket_prefix }}'"
            echo "  cloudfront_id: '${{ needs.deploy_infrastructure.outputs.cloudfront_id }}'"
            echo "  api_url: '${{ needs.deploy_infrastructure.outputs.api_url }}'"
            echo "  website_url: '${{ needs.deploy_infrastructure.outputs.website_url }}'"
            exit 1
          fi
          
          if [[ -z "$AWS_ACCOUNT_ID" ]]; then
            echo "❌ AWS Account ID is not set!"
            exit 1
          fi
          
          echo "Using bucket: $BUCKET_NAME"
          
          # Verify bucket exists
          if ! aws s3 ls "s3://$BUCKET_NAME" >/dev/null 2>&1; then
            echo "❌ S3 bucket '$BUCKET_NAME' does not exist or is not accessible"
            exit 1
          fi
          
          # Sync frontend files to S3
          aws s3 sync dist/ s3://"$BUCKET_NAME"/ \
            --delete \
            --cache-control "public, max-age=31536000" \
            --exclude "*.html" \
            --exclude "service-worker.js"
          
          # Upload HTML files with shorter cache
          aws s3 sync dist/ s3://"$BUCKET_NAME"/ \
            --cache-control "public, max-age=0, must-revalidate" \
            --include "*.html" \
            --include "service-worker.js"
          
          echo "Frontend deployed to S3 bucket: $BUCKET_NAME"
      - name: Invalidate CloudFront cache
        run: |
          DISTRIBUTION_ID="${{ needs.deploy_infrastructure.outputs.cloudfront_id }}"
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "$DISTRIBUTION_ID" \
            --paths "/*" \
            --query "Invalidation.Id" \
            --output text)
          
          echo "CloudFront invalidation created: $INVALIDATION_ID"
          echo "Distribution ID: $DISTRIBUTION_ID"
################################################################################
# 5) Post-deployment verification                                              #
################################################################################
  verify_deployment:
    name: Verify deployment
    needs: [setup, deploy_infrastructure, deploy_frontend]
    if: ${{ always() && needs.deploy_infrastructure.result == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region:        ${{ env.AWS_REGION }}
          role-to-assume:    ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}

      - name: Test API endpoint
        run: |
          API_URL="${{ needs.deploy_infrastructure.outputs.api_url }}"
          
          echo "Testing API health endpoint..."
          echo "Full API URL: $API_URL"
          
          # Test the health endpoint with proper path
          if curl -f -s "$API_URL/health" > /dev/null; then
            echo "✅ API health check passed"
          else
            echo "⚠️  API health check failed"
            echo "Trying alternative health endpoint..."
            # Try root path
            if curl -f -s "$API_URL/" > /dev/null; then
              echo "✅ API root endpoint accessible"
            else
              echo "❌ Both health and root endpoints failed"
            fi
          fi
      - name: Test website
        run: |
          WEBSITE_URL="${{ needs.deploy_infrastructure.outputs.website_url }}"
          
          echo "Testing website availability..."
          if curl -f -s "$WEBSITE_URL" > /dev/null; then
            echo "✅ Website is accessible"
          else
            echo "⚠️  Website check failed, but deployment will continue"
          fi
      - name: Deployment summary
        env:
          STACK_NAME: ${{ needs.setup.outputs.stack_name }}
        run: |
          echo "🎉 Webapp deployment completed!"
          echo ""
          echo "📊 Deployment Summary:"
          echo "  • Website URL: ${{ needs.deploy_infrastructure.outputs.website_url }}"
          echo "  • API URL: ${{ needs.deploy_infrastructure.outputs.api_url }}"
          echo "  • Bucket Prefix: ${{ needs.deploy_infrastructure.outputs.bucket_prefix }}"
          echo "  • CloudFront ID: ${{ needs.deploy_infrastructure.outputs.cloudfront_id }}"
          echo ""
          echo "🔧 Stack Status:"
          if [ -n "$STACK_NAME" ]; then
            aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --query "Stacks[0].StackStatus" \
              --output text
          else
            echo "Stack name not available"
          fi
################################################################################
# 6) Cleanup on failure                                                        #
################################################################################
  cleanup_on_failure:
    name: Cleanup failed deployment
    needs: [deploy_infrastructure, deploy_frontend]
    if: ${{ failure() && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest

    steps:      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region:        ${{ env.AWS_REGION }}
          role-to-assume:    ${{ env.AWS_ROLE_ARN }}
          role-session-name: ${{ env.AWS_ROLE_SESSION }}
      
      - name: Check stack status and cleanup if needed
        run: |
          STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo NOT_FOUND)
          
          echo "Stack status: $STATUS"
          
          if [[ "$STATUS" == "ROLLBACK_COMPLETE" || "$STATUS" == "CREATE_FAILED" ]]; then
            echo "Cleaning up failed stack..."
            aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }}
            echo "Stack deletion initiated"
          else
            echo "Stack is in a stable state, no cleanup needed"
          fi