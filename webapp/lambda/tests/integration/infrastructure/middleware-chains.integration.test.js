/**
 * Comprehensive Middleware Chain Integration Tests
 * Tests middleware interactions: auth → validation → error handling → response formatting
 * Validates complete request/response pipeline integration
 */

const request = require("supertest");

let app;

// Mock database BEFORE importing routes/modules
jest.mock("../../../utils/database", () => ({
  query: jest.fn(),
  initializeDatabase: jest.fn().mockResolvedValue(undefined),
  closeDatabase: jest.fn().mockResolvedValue(undefined),
  getPool: jest.fn(),
  transaction: jest.fn((cb) => cb({ query: jest.fn().mockResolvedValue({ rows: [] }), release: jest.fn().mockResolvedValue(undefined) })),
  healthCheck: jest.fn(),
}));

// Import the mocked database
const { query, closeDatabase, initializeDatabase} = require("../../../utils/database");

// Mock auth middleware
jest.mock("../../../middleware/auth", () => ({
  authenticateToken: jest.fn((req, res, next) => {
    req.user = { sub: "test-user-123" };
    next();
  }),
  authorizeAdmin: jest.fn((req, res, next) => next()),
  checkApiKey: jest.fn((req, res, next) => next()),
}));

// Import the mocked database


app = require("../../../server");
describe("Middleware Chain Integration", () => {
  
    beforeEach(() => {
    jest.clearAllMocks();
    query.mockImplementation((sql, params) => {
      // Default: return empty rows for all queries
      if (sql.includes("information_schema.tables")) {
        return Promise.resolve({ rows: [{ exists: true }] });
      }
      return Promise.resolve({ rows: [] });
    });
  });
  afterAll(async () => {
    await closeDatabase();
  });

  describe("Authentication → Validation → Response Pipeline", () => {
    test("should process complete middleware chain for valid requests", async () => {
      const response = await request(app)
        .get("/api/portfolio")
        .set("Authorization", "Bearer dev-bypass-token")
        .set("Content-Type", "application/json");

      expect([200, 404, 500, 501]).toContain(response.status);

      // Verify response structure (portfolio returns operational status format)
      if (response.status === 200) {
        expect(response.body).toHaveProperty("status", "operational");
        expect(response.body).toHaveProperty("message");
        expect(response.headers["content-type"]).toMatch(/application\/json/);
      } else if (response.status === 401 || response.status === 403) {
        expect(response.body).toHaveProperty("success", false);
        expect(response.body).toHaveProperty("error");
      }
    });

    test("should handle auth failure → error formatting chain", async () => {
      const response = await request(app).get("/api/portfolio").send(); // No auth header

      expect([401, 500]).toContain(response.status);

      // Verify error response format consistency
      expect(response.body).toHaveProperty("success", false);
      expect(response.body).toHaveProperty("error");
      expect(response.headers["content-type"]).toMatch(/application\/json/);
    });

    test("should handle malformed authorization headers", async () => {
      const testCases = [
        { header: "InvalidFormat token", description: "Invalid format" },
        { header: "Bearer", description: "Missing token" },
        { header: "bearer  ", description: "Empty token" },
        {
          header: "Bearer    multiple   spaces   token",
          description: "Multiple spaces",
        },
      ];

      for (const testCase of testCases) {
        const response = await request(app)
          .get("/api/portfolio")
          .set("Authorization", testCase.header);

        expect([200, 401, 403, 404, 500, 501]).toContain(response.status);

        if (response.status === 401 || response.status === 403) {
          expect(response.body).toHaveProperty("success", false);
          expect(response.body).toHaveProperty("error");
        } else if (response.status === 500) {
          // Server errors should still have some response format
          expect(response.body).toBeDefined();
        }
      }
    });
  });

  describe("Cross-Route Middleware Consistency", () => {
    test("should apply auth middleware consistently across protected routes", async () => {
      const protectedEndpoints = [
        { method: "get", path: "/api/portfolio" },
        { method: "get", path: "/api/alerts/active" },
        { method: "get", path: "/api/portfolio/summary" },
      ];

      for (const endpoint of protectedEndpoints) {
        const response = await request(app)[endpoint.method](endpoint.path);

        // Protected endpoints should return 401/403 without auth or 200 with dev bypass
        expect([200, 401, 403, 404, 500, 501]).toContain(response.status);

        if (response.status === 401 || response.status === 403) {
          expect(response.body).toHaveProperty("success", false);
          expect(response.body).toHaveProperty("error");
        }
      }
    });

    test("should format responses consistently across all routes", async () => {
      const endpoints = [
        { method: "get", path: "/api/health", auth: false },
        { method: "get", path: "/api/portfolio", auth: true },
      ];

      for (const endpoint of endpoints) {
        let requestBuilder = request(app)[endpoint.method](endpoint.path);

        if (endpoint.auth) {
          requestBuilder = requestBuilder.set(
            "Authorization",
            "Bearer dev-bypass-token"
          );
        }

        const response = await requestBuilder;

        // All responses should have consistent JSON content-type
        expect(response.headers["content-type"]).toMatch(/application\/json/);

        if (response.body && typeof response.body === "object") {
          // Portfolio endpoint returns operational status format
          if (endpoint.path === "/api/portfolio") {
            expect(response.body).toHaveProperty("status");
            expect(response.body).toHaveProperty("message");
          }
          // Health endpoint has its own format
          if (endpoint.path === "/api/health") {
            expect(response.body).toBeDefined();
          }
        }
      }
    });
  });

  describe("Error Propagation Integration", () => {
    test("should handle database connection errors gracefully", async () => {
      const response = await request(app)
        .get("/api/portfolio/positions")
        .set("Authorization", "Bearer dev-bypass-token");

      expect([200, 404, 500, 501]).toContain(response.status);

      // Even database errors should be formatted consistently
      expect(response.body).toHaveProperty("success");

      if (response.status === 500) {
        expect(response.body.success).toBe(false);
        expect(response.body).toHaveProperty("error");
      }
    });

    test("should handle invalid route requests through middleware chain", async () => {
      const response = await request(app)
        .post("/api/portfolio/nonexistent-endpoint")
        .set("Authorization", "Bearer dev-bypass-token")
        .set("Content-Type", "application/json")
        .send({ validJson: "but invalid endpoint" });

      expect([404, 500]).toContain(response.status);

      // 404 errors should be formatted consistently
      expect(response.body).toBeDefined();
      expect(response.headers["content-type"]).toMatch(/application\/json/);
    });
  });

  describe("Request Context Propagation", () => {
    test("should maintain user context through service calls", async () => {
      const response = await request(app)
        .get("/api/portfolio/summary")
        .set("Authorization", "Bearer dev-bypass-token");

      expect([200, 404, 500, 501]).toContain(response.status);

      // If successful, verify response structure
      if (response.status === 200) {
        expect(response.body).toHaveProperty("success", true);
        expect(response.body.data).toBeDefined();
      }
    });

    test("should handle concurrent requests through middleware chain", async () => {
      const concurrentRequests = Array.from({ length: 3 }, () =>
        request(app).get("/api/health")
      );

      const responses = await Promise.all(concurrentRequests);

      // All concurrent requests should be processed
      responses.forEach((response) => {
        expect([200, 401, 403, 404, 500, 501]).toContain(response.status);
        expect(response.body).toBeDefined();
      });
    });
  });

  describe("Performance Under Middleware Load", () => {
    test("should maintain middleware chain performance", async () => {
      const startTime = Date.now();

      const response = await request(app).get("/api/health");

      const duration = Date.now() - startTime;

      // Middleware chain should not add significant latency
      expect(duration).toBeLessThan(2000); // 2 seconds max for test environment
      expect([200, 404, 500, 501]).toContain(response.status);
    });
  });
});
