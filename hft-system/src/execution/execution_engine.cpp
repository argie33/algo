/**
 * Execution Engine - Smart order routing and execution algorithms
 * Handles TWAP, VWAP, and other execution strategies
 */

#include "order_management_system.cpp"
#include <algorithm>
#include <numeric>
#include <deque>

namespace HFT {

// Execution algorithm types
enum class ExecutionAlgorithm : uint8_t {
    DIRECT = 1,       // Direct market access
    TWAP = 2,         // Time Weighted Average Price
    VWAP = 3,         // Volume Weighted Average Price
    POV = 4,          // Participation of Volume
    ICEBERG = 5,      // Iceberg orders
    SNIPER = 6        // Aggressive liquidity taking
};

// Parent order for algorithmic execution
struct ParentOrder {
    uint64_t parent_id;
    uint32_t symbol_id;
    uint32_t total_quantity;
    uint32_t executed_quantity;
    double limit_price;
    uint8_t side;
    ExecutionAlgorithm algorithm;
    uint64_t start_time_ns;
    uint64_t end_time_ns;
    uint32_t strategy_id;
    bool is_active;
    
    // Algorithm-specific parameters
    struct AlgoParams {
        double participation_rate = 0.1;    // For POV (10%)
        uint32_t slice_size = 100;          // For TWAP/ICEBERG
        uint64_t slice_interval_ms = 5000;  // 5 seconds
        double price_improvement = 0.001;   // 0.1% price improvement target
        bool allow_market_orders = false;   // Use market orders if needed
        double max_spread_pct = 0.01;       // Max 1% spread to trade
    } params;
};

// Child order generated by algorithms
struct ChildOrder {
    uint64_t child_id;
    uint64_t parent_id;
    OrderBookEntry order_details;
    uint64_t scheduled_time_ns;
    bool is_sent;
};

// Market microstructure for execution decisions
struct MarketMicrostructure {
    uint32_t symbol_id;
    double bid_price;
    double ask_price;
    uint32_t bid_size;
    uint32_t ask_size;
    double last_price;
    uint32_t last_size;
    uint64_t last_timestamp_ns;
    
    // VWAP calculation
    double vwap;
    uint64_t cumulative_volume;
    double cumulative_price_volume;
    
    // Recent trade flow
    std::deque<double> recent_prices;
    std::deque<uint32_t> recent_volumes;
    std::deque<uint64_t> recent_timestamps;
    
    // Market impact estimation
    double estimated_impact;
    double volatility;
};

class ExecutionEngine {
private:
    std::unique_ptr<OrderManagementSystem> oms_;
    
    // Active parent orders
    std::unordered_map<uint64_t, ParentOrder> parent_orders_;
    std::unordered_map<uint64_t, std::vector<ChildOrder>> child_orders_;
    
    // Market data
    std::unordered_map<uint32_t, MarketMicrostructure> market_data_;
    
    // Execution metrics
    struct ExecutionMetrics {
        std::atomic<uint64_t> parent_orders_completed{0};
        std::atomic<uint64_t> child_orders_sent{0};
        std::atomic<double> avg_slippage_bps{0.0};
        std::atomic<double> avg_market_impact_bps{0.0};
        std::atomic<double> implementation_shortfall{0.0};
        std::atomic<uint64_t> avg_execution_time_ms{0.0};
    };
    
    ExecutionMetrics metrics_;
    
    // Threading
    std::thread execution_thread_;
    std::atomic<bool> running_{false};
    std::mutex execution_mutex_;
    
    // Performance tracking
    std::unordered_map<uint64_t, double> arrival_prices_;
    std::unordered_map<uint64_t, uint64_t> start_times_;
    
public:
    ExecutionEngine() : oms_(std::make_unique<OrderManagementSystem>()) {
    }
    
    ~ExecutionEngine() {
        stop();
    }
    
    void start() {
        running_ = true;
        oms_->start();
        
        execution_thread_ = std::thread([this]() {
            runExecutionLoop();
        });
    }
    
    void stop() {
        running_ = false;
        
        if (execution_thread_.joinable()) {
            execution_thread_.join();
        }
        
        oms_->stop();
    }
    
    // Submit parent order for algorithmic execution
    uint64_t submitParentOrder(const TradingSignal& signal, 
                              ExecutionAlgorithm algorithm = ExecutionAlgorithm::DIRECT) {
        
        uint64_t parent_id = generateParentId();
        uint64_t current_time = getCurrentTimeNs();
        
        ParentOrder parent;
        parent.parent_id = parent_id;
        parent.symbol_id = signal.symbol_id;
        parent.total_quantity = signal.suggested_quantity;
        parent.executed_quantity = 0;
        parent.limit_price = signal.suggested_price_ticks * 0.01;
        parent.side = signal.signal_strength > 0 ? 1 : 2;
        parent.algorithm = algorithm;
        parent.start_time_ns = current_time;
        parent.end_time_ns = current_time + (30 * 60 * 1000000000ULL); // 30 min default
        parent.strategy_id = signal.strategy_id;
        parent.is_active = true;
        
        // Set algorithm parameters based on urgency
        configureAlgorithmParams(parent, signal);
        
        {
            std::lock_guard<std::mutex> lock(execution_mutex_);
            parent_orders_[parent_id] = parent;
            child_orders_[parent_id] = std::vector<ChildOrder>();
        }
        
        // Record arrival price for performance measurement
        arrival_prices_[parent_id] = getCurrentPrice(signal.symbol_id);
        start_times_[parent_id] = current_time;
        
        return parent_id;
    }
    
    // Cancel parent order
    bool cancelParentOrder(uint64_t parent_id) {
        std::lock_guard<std::mutex> lock(execution_mutex_);
        
        auto it = parent_orders_.find(parent_id);
        if (it == parent_orders_.end()) {
            return false;
        }
        
        ParentOrder& parent = it->second;
        parent.is_active = false;
        
        // Cancel all active child orders
        auto child_it = child_orders_.find(parent_id);
        if (child_it != child_orders_.end()) {
            for (const auto& child : child_it->second) {
                if (child.is_sent) {
                    oms_->cancelOrder(child.child_id);
                }
            }
        }
        
        return true;
    }
    
    // Update market data
    void updateMarketData(const MarketDataEvent& event) {
        MarketMicrostructure& ms = market_data_[event.symbol_id];
        
        ms.symbol_id = event.symbol_id;
        ms.last_price = event.price;
        ms.last_size = event.quantity;
        ms.last_timestamp_ns = event.timestamp_ns;
        
        // Update bid/ask based on side
        if (event.side == 1) { // Bid
            ms.bid_price = event.price;
            ms.bid_size = event.quantity;
        } else { // Ask
            ms.ask_price = event.price;
            ms.ask_size = event.quantity;
        }
        
        // Update VWAP
        ms.cumulative_volume += event.quantity;
        ms.cumulative_price_volume += event.price * event.quantity;
        if (ms.cumulative_volume > 0) {
            ms.vwap = ms.cumulative_price_volume / ms.cumulative_volume;
        }
        
        // Update recent trade flow
        ms.recent_prices.push_back(event.price);
        ms.recent_volumes.push_back(event.quantity);
        ms.recent_timestamps.push_back(event.timestamp_ns);
        
        // Keep limited history
        while (ms.recent_prices.size() > 100) {
            ms.recent_prices.pop_front();
            ms.recent_volumes.pop_front();
            ms.recent_timestamps.pop_front();
        }
        
        // Calculate volatility and market impact
        updateMarketMetrics(ms);
    }
    
    // Process execution reports
    void processExecutionReports() {
        ExecutionReport report;
        while (oms_->getExecutionReport(report)) {
            handleExecutionReport(report);
        }
    }
    
    // Get execution metrics
    ExecutionMetrics getMetrics() const {
        return metrics_;
    }
    
    // Get parent order status
    ParentOrder getParentOrder(uint64_t parent_id) const {
        std::lock_guard<std::mutex> lock(execution_mutex_);
        
        auto it = parent_orders_.find(parent_id);
        if (it != parent_orders_.end()) {
            return it->second;
        }
        
        return ParentOrder{};
    }

private:
    void runExecutionLoop() {
        while (running_) {
            // Process execution reports
            processExecutionReports();
            
            // Run execution algorithms
            runExecutionAlgorithms();
            
            // Monitor and adjust active orders
            monitorChildOrders();
            
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }
    
    void runExecutionAlgorithms() {
        uint64_t current_time = getCurrentTimeNs();
        
        std::lock_guard<std::mutex> lock(execution_mutex_);
        
        for (auto& [parent_id, parent] : parent_orders_) {
            if (!parent.is_active || parent.executed_quantity >= parent.total_quantity) {
                continue;
            }
            
            // Check if parent order has expired
            if (current_time > parent.end_time_ns) {
                parent.is_active = false;
                continue;
            }
            
            // Run appropriate algorithm
            switch (parent.algorithm) {
                case ExecutionAlgorithm::DIRECT:
                    runDirectExecution(parent);
                    break;
                case ExecutionAlgorithm::TWAP:
                    runTWAP(parent, current_time);
                    break;
                case ExecutionAlgorithm::VWAP:
                    runVWAP(parent, current_time);
                    break;
                case ExecutionAlgorithm::POV:
                    runPOV(parent, current_time);
                    break;
                case ExecutionAlgorithm::ICEBERG:
                    runIceberg(parent, current_time);
                    break;
                case ExecutionAlgorithm::SNIPER:
                    runSniper(parent, current_time);
                    break;
            }
        }
    }
    
    void runDirectExecution(ParentOrder& parent) {
        // Direct execution - send entire order immediately
        if (parent.executed_quantity == 0) {
            uint32_t remaining = parent.total_quantity - parent.executed_quantity;
            createAndSendChildOrder(parent, remaining, parent.limit_price);
        }
    }
    
    void runTWAP(ParentOrder& parent, uint64_t current_time) {
        // Time Weighted Average Price execution
        uint64_t elapsed_time = current_time - parent.start_time_ns;
        uint64_t total_time = parent.end_time_ns - parent.start_time_ns;
        
        if (total_time == 0) return;
        
        // Calculate target executed quantity based on time
        double time_progress = static_cast<double>(elapsed_time) / total_time;
        uint32_t target_quantity = static_cast<uint32_t>(parent.total_quantity * time_progress);
        
        uint32_t quantity_behind = target_quantity - parent.executed_quantity;
        
        if (quantity_behind > parent.params.slice_size) {
            // Send next slice
            double slice_price = calculateSlicePrice(parent);
            createAndSendChildOrder(parent, parent.params.slice_size, slice_price);
        }
    }
    
    void runVWAP(ParentOrder& parent, uint64_t current_time) {
        // Volume Weighted Average Price execution
        const MarketMicrostructure& ms = market_data_[parent.symbol_id];
        
        if (ms.vwap == 0) return; // No VWAP data yet
        
        // Target price is VWAP with improvement
        double target_price = ms.vwap;
        if (parent.side == 1) { // Buy - try to buy below VWAP
            target_price -= parent.params.price_improvement;
        } else { // Sell - try to sell above VWAP
            target_price += parent.params.price_improvement;
        }
        
        // Check if current market allows execution at target price
        bool can_execute = false;
        if (parent.side == 1 && ms.ask_price <= target_price) {
            can_execute = true;
        } else if (parent.side == 2 && ms.bid_price >= target_price) {
            can_execute = true;
        }
        
        if (can_execute) {
            uint32_t remaining = parent.total_quantity - parent.executed_quantity;
            uint32_t slice_size = std::min(remaining, parent.params.slice_size);
            createAndSendChildOrder(parent, slice_size, target_price);
        }
    }
    
    void runPOV(ParentOrder& parent, uint64_t current_time) {
        // Participation of Volume execution
        const MarketMicrostructure& ms = market_data_[parent.symbol_id];
        
        // Calculate recent volume rate
        uint64_t lookback_time = 60 * 1000000000ULL; // 1 minute
        uint32_t recent_volume = 0;
        
        for (size_t i = 0; i < ms.recent_volumes.size(); ++i) {
            if (current_time - ms.recent_timestamps[i] <= lookback_time) {
                recent_volume += ms.recent_volumes[i];
            }
        }
        
        // Calculate our target participation
        uint32_t target_volume = static_cast<uint32_t>(recent_volume * parent.params.participation_rate);
        uint32_t remaining = parent.total_quantity - parent.executed_quantity;
        uint32_t slice_size = std::min(remaining, std::max(target_volume, parent.params.slice_size));
        
        if (slice_size > 0) {
            double slice_price = calculateSlicePrice(parent);
            createAndSendChildOrder(parent, slice_size, slice_price);
        }
    }
    
    void runIceberg(ParentOrder& parent, uint64_t current_time) {
        // Iceberg execution - show small slices
        auto& children = child_orders_[parent.parent_id];
        
        // Check if we need to send a new slice
        bool need_new_slice = true;
        for (const auto& child : children) {
            if (child.is_sent && child.order_details.state != OrderState::FILLED &&
                child.order_details.state != OrderState::CANCELLED) {
                need_new_slice = false;
                break;
            }
        }
        
        if (need_new_slice) {
            uint32_t remaining = parent.total_quantity - parent.executed_quantity;
            uint32_t slice_size = std::min(remaining, parent.params.slice_size);
            
            if (slice_size > 0) {
                double slice_price = calculateSlicePrice(parent);
                createAndSendChildOrder(parent, slice_size, slice_price);
            }
        }
    }
    
    void runSniper(ParentOrder& parent, uint64_t current_time) {
        // Aggressive liquidity taking
        const MarketMicrostructure& ms = market_data_[parent.symbol_id];
        
        // Check spread conditions
        double spread = ms.ask_price - ms.bid_price;
        double spread_pct = spread / ms.last_price;
        
        if (spread_pct <= parent.params.max_spread_pct) {
            // Aggressive price to ensure immediate execution
            double aggressive_price = parent.side == 1 ? ms.ask_price : ms.bid_price;
            
            uint32_t remaining = parent.total_quantity - parent.executed_quantity;
            uint32_t available_liquidity = parent.side == 1 ? ms.ask_size : ms.bid_size;
            uint32_t slice_size = std::min(remaining, available_liquidity);
            
            if (slice_size > 0) {
                createAndSendChildOrder(parent, slice_size, aggressive_price);
            }
        }
    }
    
    double calculateSlicePrice(const ParentOrder& parent) {
        const MarketMicrostructure& ms = market_data_[parent.symbol_id];
        
        if (parent.side == 1) { // Buy order
            // Try to buy at bid or better
            double target_price = std::min(ms.bid_price + 0.01, parent.limit_price);
            return target_price;
        } else { // Sell order
            // Try to sell at ask or better
            double target_price = std::max(ms.ask_price - 0.01, parent.limit_price);
            return target_price;
        }
    }
    
    void createAndSendChildOrder(ParentOrder& parent, uint32_t quantity, double price) {
        // Check if we already have a recent child order
        uint64_t current_time = getCurrentTimeNs();
        uint64_t min_interval = parent.params.slice_interval_ms * 1000000ULL;
        
        auto& children = child_orders_[parent.parent_id];
        if (!children.empty()) {
            const auto& last_child = children.back();
            if (current_time - last_child.scheduled_time_ns < min_interval) {
                return; // Too soon for next slice
            }
        }
        
        // Create child order
        ChildOrder child;
        child.child_id = generateChildId();
        child.parent_id = parent.parent_id;
        child.scheduled_time_ns = current_time;
        child.is_sent = false;
        
        // Create order details
        child.order_details.order_id = child.child_id;
        child.order_details.symbol_id = parent.symbol_id;
        child.order_details.quantity = quantity;
        child.order_details.price = price;
        child.order_details.side = parent.side;
        child.order_details.order_type = OrderType::LIMIT;
        child.order_details.time_in_force = TimeInForce::IOC;
        child.order_details.strategy_id = parent.strategy_id;
        
        children.push_back(child);
        
        // Send to OMS
        TradingSignal signal;
        signal.symbol_id = parent.symbol_id;
        signal.strategy_id = parent.strategy_id;
        signal.suggested_quantity = quantity;
        signal.suggested_price_ticks = static_cast<uint32_t>(price * 100);
        signal.signal_strength = parent.side == 1 ? 1.0 : -1.0;
        signal.urgency = 50; // Medium urgency
        
        uint64_t order_id = oms_->submitOrder(signal);
        if (order_id > 0) {
            child.is_sent = true;
            metrics_.child_orders_sent++;
        }
    }
    
    void handleExecutionReport(const ExecutionReport& report) {
        // Find parent order for this child order
        uint64_t parent_id = 0;
        
        {
            std::lock_guard<std::mutex> lock(execution_mutex_);
            
            for (auto& [pid, children] : child_orders_) {
                for (auto& child : children) {
                    if (child.child_id == report.order_id) {
                        parent_id = pid;
                        child.order_details.state = report.order_state;
                        child.order_details.filled_quantity += report.executed_quantity;
                        break;
                    }
                }
                if (parent_id > 0) break;
            }
        }
        
        if (parent_id > 0) {
            updateParentOrderProgress(parent_id, report);
        }
    }
    
    void updateParentOrderProgress(uint64_t parent_id, const ExecutionReport& report) {
        std::lock_guard<std::mutex> lock(execution_mutex_);
        
        auto it = parent_orders_.find(parent_id);
        if (it == parent_orders_.end()) return;
        
        ParentOrder& parent = it->second;
        parent.executed_quantity += report.executed_quantity;
        
        // Calculate performance metrics
        if (report.executed_quantity > 0) {
            updatePerformanceMetrics(parent, report);
        }
        
        // Check if parent order is complete
        if (parent.executed_quantity >= parent.total_quantity) {
            parent.is_active = false;
            metrics_.parent_orders_completed++;
            
            // Calculate final performance
            calculateFinalPerformance(parent_id);
        }
    }
    
    void updatePerformanceMetrics(const ParentOrder& parent, const ExecutionReport& report) {
        // Calculate slippage
        double arrival_price = arrival_prices_[parent.parent_id];
        double execution_price = report.execution_price;
        
        double slippage_bps = 0.0;
        if (parent.side == 1) { // Buy
            slippage_bps = ((execution_price - arrival_price) / arrival_price) * 10000.0;
        } else { // Sell
            slippage_bps = ((arrival_price - execution_price) / arrival_price) * 10000.0;
        }
        
        // Update average slippage
        double current_avg = metrics_.avg_slippage_bps.load();
        double new_avg = (current_avg * 0.9) + (slippage_bps * 0.1); // EMA
        metrics_.avg_slippage_bps.store(new_avg);
        
        // Calculate market impact (simplified)
        const MarketMicrostructure& ms = market_data_[parent.symbol_id];
        double market_impact_bps = std::abs(execution_price - ms.vwap) / ms.vwap * 10000.0;
        
        current_avg = metrics_.avg_market_impact_bps.load();
        new_avg = (current_avg * 0.9) + (market_impact_bps * 0.1);
        metrics_.avg_market_impact_bps.store(new_avg);
    }
    
    void calculateFinalPerformance(uint64_t parent_id) {
        uint64_t start_time = start_times_[parent_id];
        uint64_t end_time = getCurrentTimeNs();
        uint64_t execution_time_ms = (end_time - start_time) / 1000000ULL;
        
        // Update average execution time
        uint64_t current_avg = metrics_.avg_execution_time_ms.load();
        uint64_t new_avg = (current_avg * 15 + execution_time_ms) / 16; // EMA
        metrics_.avg_execution_time_ms.store(new_avg);
    }
    
    void monitorChildOrders() {
        // Monitor child orders for timeouts, adjustments, etc.
        uint64_t current_time = getCurrentTimeNs();
        
        std::lock_guard<std::mutex> lock(execution_mutex_);
        
        for (auto& [parent_id, children] : child_orders_) {
            for (auto& child : children) {
                if (child.is_sent && 
                    child.order_details.state == OrderState::SUBMITTED &&
                    (current_time - child.scheduled_time_ns) > 30000000000ULL) { // 30 seconds
                    
                    // Cancel stale orders
                    oms_->cancelOrder(child.child_id);
                }
            }
        }
    }
    
    void configureAlgorithmParams(ParentOrder& parent, const TradingSignal& signal) {
        // Configure algorithm parameters based on signal characteristics
        if (signal.urgency < 100) {
            // High urgency - aggressive parameters
            parent.params.slice_size = parent.total_quantity; // Single slice
            parent.params.participation_rate = 0.3; // 30% participation
            parent.params.allow_market_orders = true;
        } else if (signal.urgency < 500) {
            // Medium urgency - balanced parameters
            parent.params.slice_size = parent.total_quantity / 4; // 4 slices
            parent.params.participation_rate = 0.15; // 15% participation
            parent.params.slice_interval_ms = 10000; // 10 seconds
        } else {
            // Low urgency - patient parameters
            parent.params.slice_size = parent.total_quantity / 10; // 10 slices
            parent.params.participation_rate = 0.05; // 5% participation
            parent.params.slice_interval_ms = 30000; // 30 seconds
        }
    }
    
    void updateMarketMetrics(MarketMicrostructure& ms) {
        // Calculate volatility from recent price moves
        if (ms.recent_prices.size() >= 10) {
            std::vector<double> returns;
            for (size_t i = 1; i < ms.recent_prices.size(); ++i) {
                double ret = (ms.recent_prices[i] - ms.recent_prices[i-1]) / ms.recent_prices[i-1];
                returns.push_back(ret);
            }
            
            double mean_return = std::accumulate(returns.begin(), returns.end(), 0.0) / returns.size();
            double variance = 0.0;
            for (double ret : returns) {
                variance += (ret - mean_return) * (ret - mean_return);
            }
            variance /= (returns.size() - 1);
            ms.volatility = std::sqrt(variance);
        }
        
        // Estimate market impact (simplified Kyle's lambda)
        double spread = ms.ask_price - ms.bid_price;
        double typical_volume = 1000; // Placeholder
        ms.estimated_impact = spread / (2.0 * typical_volume);
    }
    
    double getCurrentPrice(uint32_t symbol_id) const {
        auto it = market_data_.find(symbol_id);
        if (it != market_data_.end()) {
            return it->second.last_price;
        }
        return 0.0;
    }
    
    uint64_t generateParentId() {
        static std::atomic<uint64_t> counter{1};
        return counter.fetch_add(1);
    }
    
    uint64_t generateChildId() {
        static std::atomic<uint64_t> counter{1000000};
        return counter.fetch_add(1);
    }
    
    uint64_t getCurrentTimeNs() const {
        return std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::high_resolution_clock::now().time_since_epoch()).count();
    }
};

} // namespace HFT